# Hash值计算

https://blog.csdn.net/majinggogogo/article/details/80260400

## 解决hash冲突的方法：

### **1. 开放定址法**

```text
Hi = (H(key) + di) MOD m，其中i=1,2,…,k(k<=m-1)
```

H(key)为哈希函数，m为哈希表表长，di为增量序列，i为已发生冲突的次数。其中，开放定址法根据步长不同可以分为3种：

### **1.1 线性探查法（Linear Probing）：di = 1,2,3,…,m-1**

简单地说，就是以当前冲突位置为起点，步长为1循环查找，直到找到一个空的位置，如果循环完了都占不到位置，就说明容器已经满了。举个栗子，就像你在饭点去街上吃饭，挨家去看是否有位置一样。

### **1.2 平方探测法（Quadratic Probing）：di = ±12, ±22，±32，…，±k2（k≤m/2）**

相对于线性探查法，这就相当于的步长为di = i2来循环查找，直到找到空的位置。以上面那个例子来看，现在你不是挨家去看有没有位置了，而是拿手机算去第i2家店，然后去问这家店有没有位置。

### **1.3 伪随机探测法：di = 伪随机数序列**

这个就是取随机数来作为步长。还是用上面的例子，这次就是完全按心情去选一家店问有没有位置了。

但开放定址法有这些缺点：

- 这种方法建立起来的哈希表，当冲突多的时候数据容易堆集在一起，这时候对查找不友好；
- 删除结点的时候不能简单将结点的空间置空，否则将截断在它填入散列表之后的同义词结点查找路径。因此如果要删除结点，只能在被删结点上添加删除标记，而不能真正删除结点；
- 如果哈希表的空间已经满了，还需要建立一个溢出表，来存入多出来的元素。

### **2. 再哈希法**

```text
Hi = RHi(key), 其中i=1,2,…,k
```

RHi()函数是不同于H()的哈希函数，用于同义词发生地址冲突时，计算出另一个哈希函数地址，直到不发生冲突位置。这种方法不容易产生堆集，但是会增加计算时间。

所以再哈希法的缺点是：增加了计算时间。

### **3. 建立一个公共溢出区**

假设哈希函数的值域为[0, m-1]，设向量HashTable[0,…,m-1]为基本表，每个分量存放一个记录，另外还设置了向量OverTable[0,…,v]为溢出表。基本表中存储的是关键字的记录，一旦发生冲突，不管他们哈希函数得到的哈希地址是什么，都填入溢出表。

但这个方法的缺点在于：查找冲突数据的时候，需要遍历溢出表才能得到数据。

### **4. 链地址法（拉链法）**

将冲突位置的元素构造成链表。在添加数据的时候，如果哈希地址与哈希表上的元素冲突，就放在这个位置的链表上。

拉链法的优点：

- 处理冲突的方式简单，且无堆集现象，非同义词绝不会发生冲突，因此平均查找长度较短；
- 由于拉链法中各链表上的结点空间是动态申请的，所以它更适合造表前无法确定表长的情况；
- 删除结点操作易于实现，只要简单地删除链表上的相应的结点即可。

拉链法的缺点：需要额外的存储空间。

在jdk7中

小总结：

- HashMap默认的初始化大小为16，之后每次扩充为原来的2倍。
- HashTable默认的初始大小为11，之后每次扩充为原来的2n+1。
- 当哈希表的大小为素数时，简单的取模哈希的结果会更加均匀，所以单从这一点上看，HashTable的哈希表大小选择，似乎更高明些。因为hash结果越分散效果越好。
- 在取模计算时，如果模数是2的幂，那么我们可以直接使用位运算来得到结果，效率要大大高于做除法。所以从hash计算的效率上，又是HashMap更胜一筹。
- 但是，HashMap为了提高效率使用位运算代替哈希，这又引入了哈希分布不均匀的问题，所以HashMap为解决这问题，又对hash算法做了一些改进，进行了扰动计算。



### **总结: HashMap的线程不安全主要体现在下面两个方面：**

1.在JDK1.7中，当并发执行扩容操作时会造成环形链和数据丢失的情况。，主要发生在resize（）扩容阶段

2.在JDK1.8中，在并发执行put操作时会发生数据覆盖的情况。主要发生在putVal（）阶段

相关博客

图解版：https://blog.csdn.net/zzu_seu/article/details/106669757?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163437057616780255267462%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163437057616780255267462&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-106669757.first_rank_v2_pc_rank_v29&utm_term=hashmap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AE%89%E5%85%A8&spm=1018.2226.3001.4187

简约版：https://blog.csdn.net/weixin_34121282/article/details/91480564?ops_request_misc=&request_id=&biz_id=102&utm_term=hashmap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AE%89%E5%85%A8&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-91480564.first_rank_v2_pc_rank_v29&spm=1018.2226.3001.4187



## 为什么加载因子是0.75

加载因子就是表示Hash表中元素的填满程度。

> 加载因子 = 填入表中的元素个数 / 散列表的长度

加载因子越大，填满的元素越多，空间利用率越高，但发生冲突的机会变大了；

加载因子越小，填满的元素越少，冲突发生的机会减小，但空间浪费了更多了，而且还会提高扩容rehash操作的次数。

这个跟一个统计学里很重要的原理——泊松分布有关。



## 为什么初始容量是16

在源码中有一个代码是   **static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;**   它代表的意思是默认容量是16，切是位运算，这就有几个问题了

- 为啥是位运算

因为计算机里面是二进制存储，如果直接是16的话，计算机里面需要进行进制转换，所以使用位运算更快

- 为什么是16

在jdk8源码中的 **putVal（）** 方法有一句代码

``` java
(n - 1) & hash  等同于  hash % n 进行取模运行  求余数
```

这里的n就是数组的长度，就是16，通过和hash值进行与运行来取模，

16的二进制是  10000

15的二进制是  1111

15和任何数进行 & 运行能够均匀的分布在 0 ~ 16 之间

如果 不全是1的话，那么有些index就永远也取不到
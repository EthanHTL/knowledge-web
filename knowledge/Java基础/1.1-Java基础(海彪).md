# java基础

## 1.基本数据类型

### 1.数据类型

1bit表示 1位；

1B = 8b；

1KB =1024B；

1MB  =1024KB；

。。。

#### 1.byte

- byte 数据类型是8位（1字节）、有符号的，以二进制补码表示的整数；
- 最小值是 **-128（-2^7）**；
- 最大值是 **127（2^7-1）**；
- 默认值是 **0**；
- byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；
- 例子：byte a = 100，byte b = -50。

```
public static void main(String[] args){
    System.out.println(Byte.SIZE);
    System.out.println("包装类：java.lang.Byte");
    System.out.println("最小值：Byte.MIN_value="+Byte.MIN_VALUE);
    System.out.println("最大值：Byte.MAX_value="+Byte.MAX_VALUE);
}
```



#### 2.short 

- short 数据类型是 16 位（2字节）、有符号的以二进制补码表示的整数
- 最小值是 **-32768（-2^15）**；
- 最大值是 **32767（2^15 - 1）**；
- Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；
- 默认值是 **0**；
- 例子：short s = 1000，short r = -20000。

```
public class Type {
    public static void main(String[] args){
        System.out.println(Short.SIZE);
        System.out.println("包装类：java.lang.Short");
        System.out.println("最小值：Byte.Short_value="+Short.MIN_VALUE);
        System.out.println("最大值：Byte.Short_value="+Short.MAX_VALUE);
    }
}
```



#### 3.int

- int 数据类型是32位（4字节）、有符号的以二进制补码表示的整数；
- 最小值是 **-2,147,483,648（-2^31）**；
- 最大值是 **2,147,483,647（2^31 - 1）**；
- 一般地整型变量默认为 int 类型；
- 默认值是 **0** ；
- 例子：int a = 100000, int b = -200000。

```
public class Type {
    public static void main(String[] args){
        System.out.println("基本类型：int 二进制数"+Integer.SIZE);
        System.out.println("包装类：java.lang.Integer");
        System.out.println("最小值：Byte.Integer_value="+Integer.MIN_VALUE);
        System.out.println("最大值：Byte.Integer_value="+Integer.MAX_VALUE);
    }
}
```

#### 4.long

- long 数据类型是 64 （8字节）位、有符号的以二进制补码表示的整数；

- 最小值是 **-9,223,372,036,854,775,808（-2^63）**；

- 最大值是 **9,223,372,036,854,775,807（2^63 -1）**；

- 这种类型主要使用在需要比较大整数的系统上；

- 默认值是 **0L**；

- 例子： long a = 100000L，Long b = -200000L。

  "L"理论上不分大小写，但是若写成"l"容易与数字"1"混淆，不容易分辩。所以最好大写。

```
public static void main(String[] args){
    System.out.println("基本类型：long 二进制数"+Long.SIZE);
    System.out.println("包装类：java.lang.Long");
    System.out.println("最小值：Byte.Long_value="+Long.MIN_VALUE);
    System.out.println("最大值：Byte.Long_value="+Long.MAX_VALUE);
}
```



#### 5.float

- float 数据类型是单精度、32位（4字节）、符合IEEE 754标准的浮点数；
- float 在储存大型浮点数组的时候可节省内存空间；
- 默认值是 **0.0f**；
- 浮点数不能用来表示精确的值，浮点数有限，数值接近但不等于，舍入误差，离散。如货币；
- 例子：float f1 = 234.5f。

```
public static void main(String[] args){
    System.out.println("基本类型：float 二进制数"+Float.SIZE);
    System.out.println("包装类：java.lang.Float");
    System.out.println("最小值：Byte.Float_value="+Float.MIN_VALUE);
    System.out.println("最大值：Byte.Float_value="+Float.MAX_VALUE);
}
```



#### 6.double

- double 数据类型是双精度、64 位(8字节)、符合IEEE 754标准的浮点数；
- 浮点数的默认类型为double类型；
- double类型同样不能表示精确的值，如货币；
- 默认值是 **0.0d**；
- 例子：double d1 = 123.4。

```
public class Type {
    public static void main(String[] args){
        System.out.println("基本类型：double 二进制数"+Double.SIZE);
        System.out.println("包装类：java.lang.Double");
        System.out.println("最小值：Byte.Double_value="+Double.MIN_VALUE);
        System.out.println("最大值：Byte.Double_value="+Double.MAX_VALUE);
    }
}
```

#### 7.boolean

- boolean数据类型表示1位的信息；
- 只有两个取值：true 和 false；
- 这种类型只作为一种标志来记录 true/false 情况；
- 默认值是 **false**；
- 例子：boolean one = true。

#### 8.char

- char类型是一个单一的 16 位 Unicode 字符；
- 最小值是 **\u0000**（即为 0）；
- 最大值是 **\uffff**（即为65、535）；
- char 数据类型可以储存任何字符；
- 例子：char letter = 'A';

```
public class Type {
    public static void main(String[] args){
        System.out.println("基本类型：char 二进制位数：" + Character.SIZE);
        System.out.println("包装类：java.lang.Character");
        // 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台
        System.out.println("最小值：Character.MIN_VALUE="
                + (int) Character.MIN_VALUE);
        // 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台
        System.out.println("最大值：Character.MAX_VALUE="
                + (int) Character.MAX_VALUE);
    }
}
```



注意：Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的"E+数字"表示E之前的数字要乘以10的多少次方。比如3.14E3就是3.14 × 10^3 =3140，3.14E-3 就是 3.14 x 10^-3 =0.00314。

实际上，JAVA中还存在另外一种基本类型 void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。



### 2.类型默认值

除了基本类型，其余的默认值都是null。

| **数据类型**           | **默认值** |
| :--------------------- | :--------- |
| byte                   | 0          |
| short                  | 0          |
| int                    | 0          |
| long                   | 0L         |
| float                  | 0.0f       |
| double                 | 0.0d       |
| char                   | 'u0000'    |
| String (or any object) | null       |
| boolean                | false      |

```java
public class Type {
    static boolean bool;
    static byte by;
    static char ch;
    static double d;
    static float f;
    static int i;
    static long l;
    static short sh;
    static String str;

    public static void main(String[] args) {
        System.out.println("Bool :" + bool);
        System.out.println("Byte :" + by);
        System.out.println("Character:" + ch);
        System.out.println("Double :" + d);
        System.out.println("Float :" + f);
        System.out.println("Integer :" + i);
        System.out.println("Long :" + l);
        System.out.println("Short :" + sh);
        System.out.println("String :" + str);
    }
}
```



### 3.引用类型

- 在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。
- 类、数组和接口都是引用数据类型。
- 所有引用类型的默认值都是null。
- 一个引用变量可以用来引用任何与之兼容的类型。
- 例子：Site site = new Site("Runoob")。



### 4.常量

常量的值被设定后，在程序运行时不允许改变，常量名一般使用大写字符。

Java中使用final关键字来修饰常量，声明方式和变量类似，变量类型前面的都叫做修饰符，修饰符不分前后顺序。

```
final double PI = 3.1415927;
```

虽然常量可以用小写，为了识别，尽量使用大写来表示常量。

字面量可以赋值给任何内置类型的变量

```java
byte a = 68;
char a = 'A'
```

byte，short，int，long可以用10进制，16进制和8进制进行表示。

当使用字面量的时候，前缀0表示8进制，前缀0x表示16进制。

```
int decimal = 100;
int octal = 0144;
int hexa =  0x64;
```

java的字符串常量也是表示在两个引号之间的序列

```
"Hello World"
"two\nlines"
"\"This is in quotes\""
```

字符串常量和字符常量都可以包含unicode字符

```
char a = '\u0001';
String a = "\u0001";
```

java支持一些特殊的转义字符序列

| 符号   | 字符含义                 |
| :----- | :----------------------- |
| \n     | 换行 (0x0a)              |
| \r     | 回车 (0x0d)              |
| \f     | 换页符(0x0c)             |
| \b     | 退格 (0x08)              |
| \0     | 空字符 (0x0)             |
| \s     | 空格 (0x20)              |
| \t     | 制表符                   |
| \"     | 双引号                   |
| \'     | 单引号                   |
| \\     | 反斜杠                   |
| \ddd   | 八进制字符 (ddd)         |
| \uxxxx | 16进制Unicode字符 (xxxx) |



### 5.自动类型转换

**整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。**

转换从低级到高级

```java
低  ------------------------------------>  高

byte,short,char—> int —> long—> float —> double 
```

数据类型满足以下规则

- 1. 不能对boolean类型进行类型转换。

- 2. 不能把对象类型转换成不相关类的对象。

- 3. 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。

- 4. 转换过程中可能导致溢出或损失精度，例如：

  ```java
  int i =128;   
  byte b = (byte)i;
  ```

- 5. 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：

```java
(int)23.7 == 23;        
(int)-45.89f == -45
```



#### 自动类型转换

必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。

```java
public class Type {
    public static void main(String[] args) {
        //定义一个char类型
       char c1 = 'a';
       //自动类型转换将char类型转换为int类型
       int c2 = c1;
       System.out.println(c2);
       char c3 = 'A';
       int c4 = c3+2;
        System.out.println(c4);

    }
}
```

这里a的ascall码是97，A的ascall码是65，小转大不需要强转。



#### 强制类型转换

- 1. 条件是转换的数据类型必须是兼容的。
- 2. 格式：(type)value type是要强制类型转换后的数据类型 实例：

```java
public class Type {
    public static void main(String[] args){
        int i1 = 123;
        //强制类型转换为byte
        byte b = (byte)i1;
        System.out.println("int强制类型转换为byte后的值等于"+b);
    }
}
```



#### 隐含强制类型转换

- 1. 整数的默认类型是 int。
- 2. 浮点型不存在这种情况，因为在定义 float 类型时必须在数字后面跟上 F 或者 f。



## 2.Java变量类型

Java是强类型语言，所有变量使用之前都应声明变量。

java变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。

每个变量都有类型，类型可以是基本类型和引用类型。

变量名必须是合法的标识符。

变量声明是一条完整的语句，因此每个声明必须以分号结束。

type identifier [ = value][, identifier [= value] ...] ;

格式说明：type为Java数据类型。identifier是变量名。可以使用逗号隔开来声明多个同类型变量。

int a, b, c;     // 声明三个int型整数：a、 b、c 

int d = 3, e = 4, f = 5; // 声明三个整数并赋予初值

 byte z = 22;     // 声明并初始化 z

 String s = "runoob"; // 声明并初始化字符串 s

 double pi = 3.14159; // 声明了双精度浮点型变量 pi

 char x = 'x';    // 声明变量 x 的值是字符 'x'。



### Java语言支持的变量类型有：

- 类变量：独立于方法之外的变量，用 static 修饰。
- 实例变量：独立于方法之外的变量，不过没有 static 修饰。
- 局部变量：类的方法中的变量，初始化的时候赋值。

```java
public class Variable {
    /**
     * 类变量加上一个static
     * static的意思就是静态
     */
    static int allClicks = 0;
    
    /**
     * 实例变量
     */
    String str = "hello";
    
    public void say(){
        /**
         * 局部变量
         */
        int a=111;
    }
}
```



#### java局部变量

- 局部变量声明在方法、构造方法或者语句块中；
- 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；
- 访问修饰符不能用于局部变量；
- 局部变量只在声明它的方法、构造方法或者语句块中可见；
- 局部变量是在栈上分配的；
- 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。

```java
public class Variable {
    public void age(){
        /**
         * 初始化局部变量，必须在方法或者语句块内部
         */
        int age =0;
        age+=7;
        System.out.println("年龄是："+age);
    }

    public static void main(String[] args) {
        Variable variable = new Variable();
        variable.age();
    }
}
```

结果：年龄是：7

如果将int age=0；不初始化（int age），就会报错。



#### 实例变量

- 实例变量声明在一个类中，但在方法、构造方法和语句块之外；
- 当一个对象被实例化之后，每个实例变量的值就跟着确定；
- 实例变量在对象创建的时候创建，在对象被销毁的时候销毁；
- 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息（相当于调用这个类的属性）；
- 实例变量可以声明在使用前或者使用后；
- 访问修饰符可以修饰实例变量；
- 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；
- 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；
- 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。

```
public class Employee {
    // 这个实例变量对子类可见
    public String name;
    // 私有变量，仅在该类可见
    private double salary;
    //在构造器中对name赋值
    public Employee (String empName){
        name = empName;
    }
    //设定salary的值
    public void setSalary(double empSal){
        salary = empSal;
    }
    // 打印信息
    public void printEmp(){
        System.out.println("名字 : " + name );
        System.out.println("薪水 : " + salary);
    }

    public static void main(String[] args){
        Employee empOne = new Employee("zz");
        empOne.setSalary(1000.0);
        empOne.printEmp();
    }
}
```

结果  名字 : zz ；薪水 : 1000.0



### 类变量

- 类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。
- 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝（在某些地方很重要）。
- 静态变量除了被声明为常量外很少使用，静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变。
- 静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。
- 静态变量在第一次被访问时创建，在程序结束时销毁。
- 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。
- 默认值和实例变量相似。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。
- 静态变量可以通过：*ClassName.VariableName*的方式访问。
- 类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致。

```java
public class Employee {
    //salary是静态的私有变量
    private static double salary;
    // DEPARTMENT是一个常量
    public static final String DEPARTMENT = "开发人员";
    public static void main(String[] args){
        salary = 10000;
        System.out.println(DEPARTMENT+"平均工资:"+salary);
    }
}
```

结果：开发人员平均工资:10000.0

注意：如果其他类想要访问该变量，可以这样访问：**Employee.DEPARTMENT**。



### 变量命名规范

所有变量、方法和类名：见名知意

变量命名：小驼峰（monthSalary）

类的命名：大驼峰命名（EmployeeDetail）

方法名：小驼峰（runAndGo）

构造方法名：大驼峰（EmployeeDetail）

常量命名：大写字母和下划线（MAX_SCORE）



## 3.运算符

### 位运算符

Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。

位运算符作用在所有的位上，并且按位运算。假设a = 60，b = 13;它们的二进制格式表示将如下：

```java
A = 0011 1100
B = 0000 1101
-----------------
A&B = 0000 1100
A | B = 0011 1101
A ^ B = 0011 0001
~A= 1100 0011
```

下表列出了位运算符的基本运算，假设整数变量 A 的值为 60 和变量 B 的值为 13：

| ＆   | 如果相对应位都是1，则结果为1，否则为0                        | （A＆B），得到12，即0000 1100  |
| ---- | ------------------------------------------------------------ | ------------------------------ |
| \|   | 如果相对应位都是 0，则结果为 0，否则为1                      | （A \| B）得到61，即 0011 1101 |
| ^    | 如果相对应位值相同，则结果为0，否则为1                       | （A ^ B）得到49，即 0011 0001  |
| 〜   | 按位取反运算符翻转操作数的每一位，即0变成1，1变成0。         | （〜A）得到-61，即1100 0011    |
| <<   | 按位左移运算符。左操作数按位左移右操作数指定的位数。         | A << 2得到240，即 1111 0000    |
| >>   | 按位右移运算符。左操作数按位右移右操作数指定的位数。         | A >> 2得到15即 1111            |
| >>>  | 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 | A>>>2得到15即0000 1111         |

```java
public class Test {
    public static void main(String[] args) {
        int a = 60; /* 60 = 0011 1100 */
        int b = 13; /* 13 = 0000 1101 */
        int c = 0;
        c = a & b;       /* 12 = 0000 1100 */
        System.out.println("a & b = " + c );

        c = a | b;       /* 61 = 0011 1101 */
        System.out.println("a | b = " + c );

        c = a ^ b;       /* 49 = 0011 0001 */
        System.out.println("a ^ b = " + c );

        c = ~a;          /*-61 = 1100 0011 */
        System.out.println("~a = " + c );

        c = a << 2;     /* 240 = 1111 0000 */
        System.out.println("a << 2 = " + c );

        c = a >> 2;     /* 15 = 1111 */
        System.out.println("a >> 2  = " + c );

        c = a >>> 2;     /* 15 = 0000 1111 */
        System.out.println("a >>> 2 = " + c );
    }
}
```



### 短路逻辑运算符

当使用与逻辑运算符时，在两个操作数都为true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断第二个操作了。

```java
public static void main(String[] args){
    int a = 5;//定义一个变量；
    boolean b = (a<4)&&(a++<10);
    System.out.println("使用短路逻辑运算符的结果为"+b);
    System.out.println("a的结果为"+a);
}
```

结果 ：使用短路逻辑运算符的结果为false；a的结果为5

**解析：** 该程序使用到了短路逻辑运算符(&&)，首先判断 a<4 的结果为 false，则 b 的结果必定是 false，所以不再执行第二个操作 a++<10 的判断，所以 a 的值为 5。

### 赋值运算符

| 操作符  | 描述                                                         | 例子                                     |
| :------ | :----------------------------------------------------------- | :--------------------------------------- |
| =       | 简单的赋值运算符，将右操作数的值赋给左侧操作数               | C = A + B将把A + B得到的值赋给C          |
| + =     | 加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数     | C + = A等价于C = C + A                   |
| - =     | 减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数     | C - = A等价于C = C - A                   |
| * =     | 乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数     | C * = A等价于C = C * A                   |
| / =     | 除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数     | C / = A，C 与 A 同类型时等价于 C = C / A |
| （％）= | 取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数 | C％= A等价于C = C％A                     |
| << =    | 左移位赋值运算符                                             | C << = 2等价于C = C << 2                 |
| >> =    | 右移位赋值运算符                                             | C >> = 2等价于C = C >> 2                 |
| ＆=     | 按位与赋值运算符                                             | C＆= 2等价于C = C＆2                     |
| ^ =     | 按位异或赋值操作符                                           | C ^ = 2等价于C = C ^ 2                   |
| \| =    | 按位或赋值操作符                                             | C \| = 2等价于C = C \| 2                 |

实例

```java
public static void main(String[] args) {
    int a = 10;
    int b = 20;
    int c = 0;
    c = a + b;
    System.out.println("c = a + b = " + c );
    c += a ;
    System.out.println("c += a  = " + c );
    c -= a ;
    System.out.println("c -= a = " + c );
    c *= a ;
    System.out.println("c *= a = " + c );
    a = 10 ;
    c = 15 ;
    c /= a ;
    System.out.println("c /= a = " + c );
    a = 10 ;
    c = 15 ;
    c %= a ;
    System.out.println("c %= a  = " + c );
    c <<= 2 ;
    System.out.println("c <<= 2 = " + c );
    c >>= 2 ;
    System.out.println("c >>= 2 = " + c );
    c >>= 2 ;
    System.out.println("c >>= 2 = " + c );
    c &= a ;
    System.out.println("c &= a  = " + c );
    c ^= a ;
    System.out.println("c ^= a   = " + c );
    c |= a ;
    System.out.println("c |= a   = " + c );
}
```



### 条件运算符（?:）

条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。

```java
variable x = (expression) ? value if true : value if false
```

variable：变量类型；x：变量名；（expression）：判断值 ；？：判断符号；value if  true：值正确；value if false：值错误

实例

```java
public class Test {
    public static void main(String[] args){
        int a , b;
        a = 10;
        // 如果 a 等于 1 成立，则设置 b 为 20，否则为 30
        b = (a == 1) ? 20 : 30;
        System.out.println( "Value of b is : " +  b );

        // 如果 a 等于 10 成立，则设置 b 为 20，否则为 30
        b = (a == 10) ? 20 : 30;
        System.out.println( "Value of b is : " + b );
    }
}
```

结果 ：Value of b is : 30；Value of b is : 20



### instanceof 运算符（关键字）

该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。

```java
( Object reference variable ) instanceof  (class/interface type)
```

( Object reference variable ) ：变量名 ；instanceof：运算符；class/interface：类或者接口 ；type：类型

```java
String name = "James";
boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回true
```

如果被比较的对象兼容于右侧类型,该运算符仍然返回true。

```java
boolean result = obj instanceof Class
```

其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。

```java
class Vehicle {}

public class Car extends Vehicle {
    public static void main(String[] args){
        Vehicle a = new Car();
        boolean result =  a instanceof Car;
        System.out.println( result);
    }
}

```

结果：true

注意：

- obj必须是引用类型，不能是基本类型

- instanceof 运算符只能用作对象的判断。

- ```java
  System.out.println(null instanceof Object);//false
  ```

- obj为class类的实例对象 

  ```java
  Student student = new Student();
  System.out.println(student instanceof Student);
  ```

- obj为class接口的实现类

- obj为class的直接或者间接类

  ```java
  Object object = new Student();
  	Student student = new Student();
      System.out.println(student instanceof Student);//true
      System.out.println(student instanceof Person);//true
  	//System.out.println(student instanceof Teacher);//同级没有直接关系
      System.out.println(student instanceof Object);//间接类
  ```

  









### Java运算符优先级

在一个多运算符的表达式中，运算符优先级不同会导致最后得出的结果差别甚大，下表中具有最高优先级的运算符在的表的最上面，最低优先级的在表的底部。

| 类别     | 操作符                                     | 关联性   |
| :------- | :----------------------------------------- | :------- |
| 后缀     | () [] . (点操作符)                         | 左到右   |
| 一元     | expr++ expr--                              | 从左到右 |
| 一元     | ++expr --expr + - ～ ！                    | 从右到左 |
| 乘性     | * /％                                      | 左到右   |
| 加性     | + -                                        | 左到右   |
| 移位     | >> >>>  <<                                 | 左到右   |
| 关系     | > >= < <=                                  | 左到右   |
| 相等     | == !=                                      | 左到右   |
| 按位与   | ＆                                         | 左到右   |
| 按位异或 | ^                                          | 左到右   |
| 按位或   | \|                                         | 左到右   |
| 逻辑与   | &&                                         | 左到右   |
| 逻辑或   | \| \|                                      | 左到右   |
| 条件     | ？：                                       | 从右到左 |
| 赋值     | = + = - = * = / =％= >> = << =＆= ^ = \| = | 从右到左 |
| 逗号     | ，                                         | 左到右   |



## 4.Java switch case 语句

switch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。

**语法**

switch case 语句语法格式如下：

```java
switch(expression){
    case value :
        //语句
        break; //可选
    case value :
        //语句
        break; //可选
    //你可以有任意数量的case语句
    default : //可选
        //语句
}
```

switch case 语句有如下规则：

- switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。
- switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。
- case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。
- 当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。
- 当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。
- switch 语句可以包含一个 default 分支，该分支一般是 switch 语句的最后一个分支（可以在任何位置，但建议在最后一个）。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。

**switch case 执行时，一定会先进行匹配，匹配成功返回当前 case 的值，再根据是否有 break，判断是否继续输出，或是跳出判断。**

```
public class Test {
    public static void main(String args[]) {
        char grade = 'c';

        switch (grade){
            case 'a':
                System.out.println("优秀");
                break;
            case 'b':
            case 'c':
                System.out.println("良好");
                break;
            case 'd':
                System.out.println("及格");
                break;
            case 'e':
                System.out.println("不及格");
                break;
            default:
                System.out.println("未知等级");

        }
        System.out.println("等级是："+grade);
    }
}
```



如果case语句块中没有break语句的时候，JVM并不会输出case对应的返回值，而是继续匹配，匹配不成功则返回默认的case。

```java
public class Test {
    public static void main(String args[]){
        int i = 5;
        switch(i){
            case 0:
                System.out.println("0");
            case 1:
                System.out.println("1");
            case 2:
                System.out.println("2");
            default:
                System.out.println("default");
        }
    }
}
```

结果：false



如果 case 语句块中没有 break 语句时，匹配成功后，从当前 case 开始，后续所有 case 的值都会输出。

```
public class Test {
    public static void main(String[] args){
        int i = 1;
        switch(i){
            case 0:
                System.out.println("0");
            case 1:
                System.out.println("1");
            case 2:
                System.out.println("2");
            default:
                System.out.println("default");
        }
    }
}
```

结果：

1
2
default



如果当前匹配成功的 case 语句块没有 break 语句，则从当前 case 开始，后续所有 case 的值都会输出，如果后续的 case 语句块有 break 语句则会跳出判断。

```java
public class Test {
    public static void main(String[] args){
        int i = 1;
        switch(i){
            case 0:
                System.out.println("0");
            case 1:
                System.out.println("1");
            case 2:
                System.out.println("2");
            case 3:
                System.out.println("3"); break;
            default:
                System.out.println("default");
        }
    }
}
```

结果：1,2,3

**扩展**

jdk7的新特征，表达式可以使字符串，字符的本质还是数字

```
public static void main(String[] args) {
    //jdk7的新特征，可以使用字符串作为switch的参数
    //字符的本质还是数字
    //反编译 java -- class（字节码文件） ----反编译(idea)
    String name = "张三";
    switch (name){
        case "张三":
            System.out.println("我是张三");
            break;
        case "李四":
            System.out.println("我是李四");
            break;
        case "王五":
            System.out.println("我是王五");
            break;
        default:
            break;
    }
}
我是张三
```

**反编译**

```
public class SwitchDemo01 {
    public SwitchDemo01() {
    }

    public static void main(String[] args) {
        String name = "张三";
        byte var3 = -1;
        switch(name.hashCode()) {
        case 774889:
            if (name.equals("张三")) {
                var3 = 0;
            }
            break;
        case 842061:
            if (name.equals("李四")) {
                var3 = 1;
            }
            break;
        case 937065:
            if (name.equals("王五")) {
                var3 = 2;
            }
        }

        switch(var3) {
        case 0:
            System.out.println("我是张三");
            break;
        case 1:
            System.out.println("我是李四");
            break;
        case 2:
            System.out.println("我是王五");
        }

    }
}
```

可以看出字符串判断也是通过数字（name.hashCode()）来进行判断



## 5.Java Number & Math 类

一般地，当需要使用数字的时候，我们通常使用内置数据类型，如：**byte、int、long、double** 等。

实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情形。Java 语言为每一个内置数据类型提供了对应的包装类。

所有的包装类**（Integer、Long、Byte、Double、Float、Short）**都是抽象类 Number 的子类

| 包装类    | 基本数据类型 |
| :-------- | :----------- |
| Boolean   | boolean      |
| Byte      | byte         |
| Short     | short        |
| Integer   | int          |
| Long      | long         |
| Character | char         |
| Float     | float        |
| Double    | double       |

这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。Number 类属于 java.lang 包。

```
public class Test {
    public static void main(String[] args){
        Integer x = 5;
        x =  x + 10;
        System.out.println(x);
    }
}
```

结果：15

解析：当 x 被赋为整型值时，由于x是一个对象，所以编译器要对x进行装箱。然后，为了使x能进行加运算，所以要对x进行拆箱。



### Java Math 类

Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。

Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。

```java
public class Test {
    public static void main (String[] args)
    {
        System.out.println("90 度的正弦值：" + Math.sin(Math.PI/2));
        System.out.println("0度的余弦值：" + Math.cos(0));
        System.out.println("60度的正切值：" + Math.tan(Math.PI/3));
        System.out.println("1的反正切值： " + Math.atan(1));
        System.out.println("π/2的角度值：" + Math.toDegrees(Math.PI/2));
        System.out.println(Math.PI);
    }
    
}
```

结果：

90 度的正弦值：1.0
0度的余弦值：1.0
60度的正切值：1.7320508075688767
1的反正切值： 0.7853981633974483
π/2的角度值：90.0
3.141592653589793

### Number & Math 类方法

下面的表中列出的是 Number & Math 类常用的一些方法：（这里有些不懂得可以去网上查阅资料）

| 序号 | 方法与描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | xxxValue()将 Number 对象转换为xxx数据类型的值并返回。        |
| 2    | compareTo() 将number对象与参数比较。                         |
| 3    | equals() 判断number对象是否与参数相等。                      |
| 4    | valueOf()返回一个 Number 对象指定的内置数据类型。            |
| 5    | toString() 以字符串形式返回值。                              |
| 6    | parseInt() 将字符串解析为int类型。                           |
| 7    | abs()返回参数的绝对值。                                      |
| 8    | ceil() 返回大于等于( >= )给定参数的的最小整数，类型为双精度浮点型。 |
| 9    | floor() 返回小于等于（<=）给定参数的最大整数 。              |
| 10   | rint()返回与参数最接近的整数。返回类型为double。             |
| 11   | round() 它表示**四舍五入**，算法为 **Math.floor(x+0.5)**，即将原来的数字加上 0.5 后再向下取整，所以，Math.round(11.5) 的结果为12，Math.round(-11.5) 的结果为-11。 |
| 12   | min() 返回两个参数中的最小值。                               |
| 13   | max() 返回两个参数中的最大值。                               |
| 14   | exp()返回自然数底数e的参数次方。                             |
| 15   | log() 返回参数的自然数底数的对数值。                         |
| 16   | pow() 返回第一个参数的第二个参数次方。                       |
| 17   | sqrt()求参数的算术平方根。                                   |
| 18   | sin() 求指定double类型参数的正弦值。                         |
| 19   | cos() 求指定double类型参数的余弦值。                         |
| 20   | tan() 求指定double类型参数的正切值。                         |
| 21   | asin() 求指定double类型参数的反正弦值。                      |
| 22   | acos()求指定double类型参数的反余弦值。                       |
| 23   | atan() 求指定double类型参数的反正切值。                      |
| 24   | atan2() 将笛卡尔坐标转换为极坐标，并返回极坐标的角度值。     |
| 25   | toDegrees() 将参数转化为角度。                               |
| 26   | toRadians()将角度转换为弧度。                                |
| 27   | random() 返回一个随机数。                                    |

### Math 的 floor,round 和 ceil 方法实例比较

| 参数 | Math.floor | Math.round | Math.ceil |
| :--- | :--------- | :--------- | :-------- |
| 1.4  | 1          | 1          | 2         |
| 1.5  | 1          | 2          | 2         |
| 1.6  | 1          | 2          | 2         |
| -1.4 | -2         | -1         | -1        |
| -1.5 | -2         | -1         | -1        |
| -1.6 | -2         | -2         | -1        |

```
public class Test{
    public static void main(String[] args){
        double[] nums = { 1.4, 1.5, 1.6, -1.4, -1.5, -1.6 };
        for (double num : nums) {
            test(num);
        }
    }
    private static void test(double num) {
        System.out.println("Math.floor(" + num + ")=" + Math.floor(num));
        System.out.println("Math.round(" + num + ")=" + Math.round(num));
        System.out.println("Math.ceil(" + num + ")=" + Math.ceil(num));
    }
}
```

结果：

Math.floor(1.4)=1.0
Math.round(1.4)=1
Math.ceil(1.4)=2.0
Math.floor(1.5)=1.0
Math.round(1.5)=2
Math.ceil(1.5)=2.0
Math.floor(1.6)=1.0
Math.round(1.6)=2
Math.ceil(1.6)=2.0
Math.floor(-1.4)=-2.0
Math.round(-1.4)=-1
Math.ceil(-1.4)=-1.0
Math.floor(-1.5)=-2.0
Math.round(-1.5)=-1
Math.ceil(-1.5)=-1.0
Math.floor(-1.6)=-2.0
Math.round(-1.6)=-2
Math.ceil(-1.6)=-1.0





## 6.Scanner对象

java.util.Scanner是java5的新特性，我们可以通过Scanner类来获取用户输入

**基本语法**

Scanner  sc = new Scanner(System.in);

通过Scanner类的next()与nextLine()方法获取输入的字符串，在读取之前，我们需要使用hasNext()与hasNextLine()判断是否还有输入的数据。 

next:

```java
public static void main(String[] args) {
    //创建一个扫描器对象，用于接收键盘数据
    Scanner sc = new Scanner(System.in);
    System.out.println("使用next方式接收：");
    if(sc.hasNext()){
        String next = sc.next();
        System.out.println("输出的内容为："+next);
    }
    //凡是属于IO流，使用完之后就必须关闭，不然会一直占用资源，养成良好习惯。
    sc.close();
}

使用next方式接收：
hello world!
输出的内容为：hello
```

> 读取到有效字符即结束

> 对输入有效字符之前遇到的空白，next（）方法会将其自动去掉

> 只有输入有效字符后，才能将其后面输入的分割符作为空白符或者结束符

> next（）不能得到带有空格的字符。

nextLine:

~~~java
public static void main(String[] args) {
        //从键盘接收数据
        Scanner sc = new Scanner(System.in);
        System.out.println("使用nextLine()接收：");
        //判断时候还有下一个值
        if(sc.hasNextLine()){
            String nextLine = sc.nextLine();
            System.out.println("输出的内容："+nextLine);
        }
        //不要忘记关闭IO流，减少资源浪费。
        sc.close();
    }

使用nextLine()接收：
hello world!
输出的内容：hello world!
~~~

> 以enter作为结束符，也就是说nextLine（）方法返回的是输入回车之前的所有字符。

> 可以获得空白。



进阶知识

~~~java
public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        //从键盘输入数据
        int i1 = 0;
        float i2 = 0.0f;

        System.out.println("请输入整数：");
        if(scanner.hasNextInt()){
            i1 = scanner.nextInt();
            System.out.println("输出的整数为："+i1);
        }else{
            System.out.println("输出的不是整数！");
        }

        System.out.println("请输入小数：");
        if(scanner.hasNextFloat()){
            i2 = scanner.nextFloat();
            System.out.println("输出的小数为："+i1);
        }else{
            System.out.println("输出的不是小数！");
        }
        scanner.close();
    }
正确输入
请输入整数：
10
输出的整数为：10
请输入小数：
1.5
输出的小数为：1.5

错误输入
请输入整数：
10.1
输出的不是整数！
请输入小数：
输出的小数为：10.1
~~~

**测试**

使用scanner求和与求平均数，每输入一个数据用回车确认，通过输入非数字来结束输入并且输出结果。

```
public static void main(String[] args) {
   
    Scanner scanner = new Scanner(System.in);

    //和
    double sum = 0.0;
    //输入个数
    Integer s = 0;
    System.out.println("请输入数据：");
    while (scanner.hasNextDouble()) {
        double v = scanner.nextDouble();
        s++;
        sum += v;
    }
    System.out.println(s + "当前个数的总数:" + sum);
    System.out.println(s + "当前个数的平均数" + (sum / s));
    scanner.close();
}

请输入数据：
10
20
30
40
CAD
4当前个数的总数:100.0
4当前个数的平均数25.0
```

**注意**：不要忘记关闭scanner流，减少资源浪费。



## 7.方法

> java方法是语句的集合，他们在一起执行一个功能。
>
> 方法是解决一类问题步骤的有序集合
>
> 方法包含于类和对象中
>
> 方法在程序中被创建，在其他地方被引用
>
> java的方法类似于其他语言的函数，用来完成特定功能的代码片段

**方法的定义**

一个方法包括方法头和方法体：

**修饰符**：是可选的（public、private等），告诉编译器如何调用方法。定义该方法的访问类型；

**返回值类型**：方法可能会返回值。returnValueType是方法返回值类型。有些方法执行所需的操作，但是没有返回值，比如void。

**方法名**：是方法的实际名称，方法名和参数表共同构成参数签名。

**参数类型**：参数就像是一个占位符。当方法被调用时，传递值给参数。这个值被称为变量或者实参。参数列表是指方法的参数类型、顺序和参数个数。参数是可选的，方法可以不包括任何参数。

1. 形式参数：在方法被调用时用于接收外界输入的数据（定义方法的参数）
2. 实参：调用方法时实际传给方法的数据（接收的参数）

**方法体**：方法体包含具体的语句，定义该方法的功能。



修饰符 + 返回值类型 + 方法名（参数类型 参数名，参数类型 参数名）{

​	方法体

}

**设计方法的原则**

方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候尽量保持方法的原子性，就是一个方法只能完成一个功能，这样利于我们后期扩展。

**实例**

System.out.printIn()；

System表示一个类。out表示对象，printIn()表示方法





```java
//main方法
    public static void main(String[] args) {
        //1,2实际参数
        int add = add(1, 2);
        System.out.println(add);
    }
    //加法，a,b表示形式参数，定义的作用
    public static int add(int a,int b){
        return a+b;//除了返回0之外，还有一个功能就是终止方法
    }
结果
3
```

**解释**

public static 表示 修饰符 ；int 表示返回的类型（整型）；add：方法名；（int a， int b）：参数a和参数b，类型都是int。return a+b:表示方法体。



**方法调用**

> 语法：对象.方法名(实参列表)；

> java支持两种调用方法的方式，根据方法是否返回值来选择；

> 当方法返回一个值的时候。方法调用通常被当做一个值，例如。

~~~java
int add = add(1, 2);
~~~

> 如果方法的返回值是void，那么就是一条语句

~~~java
System.out.println("hello world!");
~~~

**拓展** ：值传递（java）和引用传递



## 8.方法的重载

重载就是在一个类中，有相同的函数名称（方法名称），但是参数不同

**方法重载的规则**：

- 方法名称必须相同
- 方法参数列表必须不同（个数不同、类型不同、参数排列顺序不同）
- 方法的返回类型可以相同也可以不同
- 仅仅返回类型的不同不能称为方法的重载

**实现理论**

> 方法名称相同时，编译器会去根据调用方法的参数个数、参数类型等逐个匹配，已选择对应的方法，如果匹配失败，则编译器报错。





**实例**

~~~java
//main方法
    public static void main(String[] args) {
        //1,2实际参数
        int add = add(10, 20);
        double add1 = add(10.0, 20.0);
        System.out.println(add);
        System.out.println(add1);

    }
    //加法，a,b表示形式参数
    public static int add(int a,int b){
        return a+b;//除了返回0之外，还有一个功能就是终止方法
    }

    public static double add(double a,double b){
        return a+b;
    }
结果
30
30.0
~~~

**解释**：方法名称一致，参数类型不一致，编译器根据传递的参数识别属于哪个方法，如果未识别到，就会报错。



## 9.可变参数



- jdk1.5开始，java支持传递同类型的可变参数给一个方法
- 在方法声明中，在指定参数类型后加一个省略号（...）
- 一个方法中只能指定一个参数，必须是方法的最后一个参数，任何普通的参数必须在它之前声明。

```java
public static void main(String[] args) {
    Demo02 demo02 = new Demo02();
    demo02.test(1,2,4,3,5);
}
public void test(int x,int ...i){
    System.out.println(x);
    System.out.println(i[0]);
    System.out.println(i[1]);
    System.out.println(i[2]);
    System.out.println(i[3]);
}
```

解释：可变参数是放在方法的参数列表最后面，可变参数的数据类型必须一致。



## 10.递归

- A方法调用A方法，自己调用自己
- 利用递归可以用简单的程序解决复杂的问题，通常将一个大的问题解析成许多个较小的问题来求解。递归策略只需少量的程序就可以描述出解题过程中需要的多次重复的计算，极大地减少代码量。递归的能力在于用有限的语句来定义无限对象的集合。



**递归包含两个部分：**

> 递归头：什么时候不调用自身方法。如果没有头，程序进入死循环。
>
> 递归体：什么时候需要调用自身方法。

**实例**

~~~java
public static void main(String[] args) {
        System.out.println(f(5));
    }

    //1! = 1
    //2! = 2*1
    //3! = 3*2*1
    //i! = i*f(i-1)

    public static int f(int i){
        if(i==1){
            return 1;
        }else {
            return i*f(i-1);
        }
    }
结果
120
~~~

**解释**：递归的方法头（边界条件）必须定义，这里是i=1的时候，前阶段：返回阶段n*（n-1）。

总结：递归因为是在栈操作，电脑支持的栈数值不大，所以递归只适用小数值进行操作，大数值会影响电脑运行（卡机）。

## 11.数组

数组是相同类型数据的有序集合

数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成。

其中，每一个数据称作一个数组元素，每一个数组元素可以通过下标来访问他们。

数组的元素是通过索引进行访问，下标从0开始。

获取数组长度:arrayList.length

**数组的声明和创建**

**语法**

数组类型	数组名称 = new 数组类型[数组长度]；

**实例**

~~~java
public static void main(String[] args) {
        //声明一个数组
       int[] nums;
        //创建一个数组
       nums = new int[10];

       //数组元素赋值
        nums[0] = 1;
        nums[1] = 2;
        nums[2] = 3;
        nums[3] = 4;
        nums[4] = 5;
        nums[5] = 6;
        nums[6] = 7;
        nums[7] = 8;
        nums[8] = 9;
        nums[9] = 10;

        //计算所有元素的和
        int sum =0;

        for(int i=0;i<nums.length;i++){
            sum+=nums[i];
        }

        System.out.println(sum);
    }

结果
55
~~~

解释：声明数组  int[] nums:这里只是和声明了数组，但是没有设置数组长度；创建数组 nums=new int[10]： 创建数组；num[0]:根据数组下标进行赋值；

如果某个下标没有值，就会根据数组的值类型输出默认值，比如int类型默认值就是0；nums.length：数组长度

**三种数组初始化**

- 静态初始化

~~~java
 int[] a ={1,2,3};
 Demo02[] demo02s = {new Demo02(1,2),new Demo02(2,3)};
~~~

**解释**：new Demo02（1，2）表示调用Demo2类的构造方法，将1,2这两个参数实例变量进行赋值放在数组里面，同理new Demo02（2,3）也是一样的。

- 动态初始化（包含默认初始化）

~~~java
//动态初始化
        int[] a = new int[2];
        a[0] = 1;
        a[1] = 2;
~~~

**数组的默认初始化：**

```java
//默认初始化
int[] a = new int[2];
System.out.println(a[0]);
结果
0
```

数组是引用类型，它的元素相当于类的实例变量，因此数组一旦分配空间，其中的元素也被按照实例变量同样的方式隐藏初始化（意思就是你初始化的时候没有设置值，他会默认给你设置一个默认值，比如你定义的是int类型的数组，默认值为0）。



**数组的四个特点**

1. 数组长度是确定的，数组长度一旦被确定就不能够改变。

2. 其元素必须是相同类型，不能出现混合类型。

3. 数组元素是任何数据类型，包括基本类型和引用类型。

4. 数组变量是引用类型，数组也可以看成是对象，数组中的每一个元素相当于该对象的成员变量。数组本身就是对象，java中的对象是在堆中，因此数组无论保存原始类型还是其他对象类型，**数组对象本身是在堆中**。

   

**数组边界**

**下标的合法区域**：[0,length-1],如果越界就会报错。

~~~java
 public static void main(String[] args) {
       int[] arr = new int[2];
        System.out.println(arr[2]);

    }
结果
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 2
	at test.base.method.Demo02.main(Demo02.java:6)    
~~~

解释：数组超出索引，也可以是数组下标越界。



## 12.内存分析

**简单内存分析**

![](img\中心主题.png)

## 13.冒泡排序

冒泡排序是最出名的排序算法，总共有八大排序

冒泡排序的代码比较简单，两层循环，外层冒泡轮数，里层依次比较，时间复杂度为（n2）； 



~~~java
    //比较相邻两个数大小，如果第一个数大于第二个数就互换位置
    //每次比较都会产生最大和最小数
    //下一轮会少一次排序
    //循环至结束

    public static void main(String[] args) {
        int[] arr = {12,11,445,141,1,2,4,78,99};
        int temp ;
        for (int i = 0; i <arr.length-1 ; i++) {
            for (int j = 0; j <arr.length-1-i ; j++) {
                if(arr[j]>arr[j+1]){
                    temp = arr[j];
                    arr[j]=arr[j+1];
                    arr[j+1] = temp;
                }
            }
        }
        System.out.println(Arrays.toString(arr));
    }
结果
[1, 2, 4, 11, 12, 78, 99, 141, 445]
~~~

**解释**：外层循环表示循环数组中的每一个数，内存循环的j<arr.length-1-i：表示循环一个之后，数组就减少一个进行循环，里面的判断表示只要前面一个数据大于后面就转换位置。



## 14.稀疏数组

当数组中大部分元素是0，或者同一值的时候，就可以使用稀疏数组来存储数据

稀疏数组的处理方式是：

- 记录数组几行几列，几个不同的值
- 把具有不同值的元素和行列及值记录在一个小的规模当中，从而缩小程序的规模

```java
public static void main(String[] args) {
    //定义一个二维数组
    int[][] arrs = new int[11][11];
    //赋值
    arrs[1][1] = 1;
    arrs[2][2] = 2;

    System.out.println("输出原始数组");
    for (int[] arr : arrs) {
        for (int i : arr) {
            System.out.print(i+"\t");
        }
        System.out.println();
    }
    System.out.println("============================");
    //转换为稀疏数组保存
    //获取有效值的个数
    int sum=0;
    for (int i = 0; i <11; i++) {
        for (int j = 0; j < 11; j++) {
            if(arrs[i][j]!=0){
                sum++;
            }
        }
    }
    System.out.println("有效值的个数："+sum);

    //创建一个稀疏数组的数组
    int[][] arrs1 = new int[sum+1][3];
    arrs1[0][0] = 11;
    arrs1[0][1] = 11;
    arrs1[0][2] = sum;

    //遍历二维数组，将非0的值，放在稀疏数组中
    int count=0;
    for (int i = 0; i < arrs.length; i++) {
        for (int j = 0; j < arrs[i].length; j++) {
            if(arrs[i][j]!=0){
                count++;
                arrs1[count][0] =i;
                arrs1[count][1] =j;
                arrs1[count][2] =arrs[i][j];
            }
        }
    }
    System.out.println("稀疏数组");
    for (int i = 0; i < arrs1.length; i++) {
        System.out.println(arrs1[i][0]+"\t"
                +arrs1[i][1]+"\t"
                +arrs1[i][2]+"\t"
        );
    }
    System.out.println("====================");
    System.out.println("还原");
    //1.读取稀疏数组
    int[][] arrs2 = new int[arrs1[0][0]][arrs1[0][1]];
    //给其中一个元素还原他的值
    for (int i = 1; i < arrs1.length; i++) {
        arrs2[arrs1[i][0]][arrs1[i][1]] = arrs1[i][2];
    }

    System.out.println("还原好的数组");
    for (int[] ints : arrs2) {
        for (int anInt : ints) {
            System.out.print(anInt+"\t");
        }
        System.out.println();
    }

}
结果：
输出原始数组
0	0	0	0	0	0	0	0	0	0	0	
0	1	0	0	0	0	0	0	0	0	0	
0	0	2	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
============================
有效值的个数：2
稀疏数组
11	11	2	
1	1	1	
2	2	2	
====================
还原
还原好的数组
0	0	0	0	0	0	0	0	0	0	0	
0	1	0	0	0	0	0	0	0	0	0	
0	0	2	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	

```

## 15.集合框架

- Collection接口：单列集合，用来存储一个个的对象
- List接口：存储有序，可重复的数据 --->“动态”数组 ArrayList、LinkedList、Vector
- Set接口：存储无序，不可重复的数据  --->高中讲的“集合” HashSet、LinkedHashSet、TreeSet
- Map接口：双列集合，用来存储一对（key -value）一对的数据   (HashMap<----LinkedHashMap)、TreeMap、（Hashtable<----Properties）

### 15.1 Collection接口

~~~java
/**
 * @author 接口中声明的方法测试
 *
 */
public class Base01 {

    @Test
    public  void test01() {
        Collection collection = new ArrayList<>();
        collection.add(123);
        collection.add("123");
        collection.add(new String("tom"));
        collection.add(new Person("张三",20));
        collection.add(567);
        collection.add(false);
        //1.contains(Obj obj):判断当前集合是否包含对象
        //我们在判断的时候是调用的obj对象的所在类的equals()方法。如果obj的类是自己定义的，需要自己去重写equals()方法
        boolean contains = collection.contains(123);
        System.out.println(contains);
        //此时这里是比较的值，相当于是重写了equals的方法
        System.out.println(collection.contains(new String("tom")));
        //因为是这个类的对象，里面并没有重写equals()方法，所以这里判断的是==，可以在Person类里面添加该方法
        System.out.println(collection.contains(new Person("张三",20)));
        //2.containsAll(Collection coll1):判断形参coll1中的所有元素是否都存在当前集合中
        Collection coll1 = Arrays.asList(123,456);
        System.out.println(collection.containsAll(coll1));
    }
结果：    
true
true
true
false
    @Test
    public void test02(){
        //3.remove(Object obj):从当前集合中移除obj元素
        Collection coll = new ArrayList<>();
        coll.add(123);
        coll.add("789");
        coll.add(new String("tom"));
        coll.add(new Person("张三",20));
        coll.add(false);

        coll.remove(1234);
        System.out.println(coll);

        coll.remove(new Person("张三",20));
        System.out.println(coll);

        //4.removeAll(Collection coll1):从当前集合中移除与coll形参中的有相同的元素，去交集
        Collection coll1 = Arrays.asList(123,456);
        coll.removeAll(coll1);
        System.out.println(coll);
    }
结果：
[123, 789, tom, Person{name='张三', age=20}, false]
[123, 789, tom, false]
[789, tom, false]

    @Test
    public void test03(){
        Collection coll = new ArrayList<>();
        coll.add(123);
        coll.add("789");
        coll.add(new String("tom"));
        coll.add(new Person("张三",20));
        coll.add(false);

        //4.retainAll(Collection coll1):求交集：获取当前集合和形参coll1集合的交集，并且返回给当前集合
        Collection coll1 = Arrays.asList(123,false,997,new String("abc"));
        coll.retainAll(coll1);
        System.out.println(coll);
    }
结果：
[123, false]
    @Test
    public void test04(){
        Collection coll = new ArrayList<>();
        coll.add(123);
        coll.add("789");
        coll.add(new String("tom"));
        coll.add(new Person("张三",20));
        coll.add(false);

        //5.equals(Object obj):判断当前集合与形参数据是否一致，如果想让结果为true，就必须看这个集合的类型
        Collection coll1 = new ArrayList<>();
        coll1.add("789");
        coll1.add(123);
        coll1.add(new String("tom"));
        coll1.add(new Person("张三",20));
        coll1.add(false);
        
        System.out.println(coll.equals(coll1));
    }
结果：
false 
~~~

**总结：**使用collection进行判断数据是否包含使用的是equals的方法来比较的。但如果判断的是一个对象，需要在对象的类里面重写equals()方法进行比较，不然判断的时候就是使用“==”来比较，结果可能出现错误。containsAll(Collection coll1)方法是用来比较这两个collection其中一个是否包含另一个的所有数据。不管是remove或者retainAll都是通过equals()方法进行判断。判断的时候都是根据这个集合的类型进行判断的。

### 15.2 Iterator迭代器接口

使用Iterator接口遍历集合元素

- Iterator对象称为迭代器（设计模式的一种），主要遍历Collection集合中的元素
- GOF给迭代器模式定义为：提供一种方法访问一个容器（container）对象中各个元素，而又不用暴露该对象的内部细节。**迭代器模式，就是为了容器而生的**

比如公交车上的售票员、空姐等。

- Collection接口继承了java.lang.Iterator接口，该接口有一个iterator()方法，所有实现了Collection接口的集合类都有一个Iterator()方法，用以返回一个Iterator接口的对象。
- Iterator仅用于遍历集合，Iterator本身不提供承装对象的能力。如果需要创建Iterator对象，则必须有一个被迭代的集合(这里可以认为就是售票员)。
- 集合对象每个调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。
- 在调用it.next()方法之前，必须要调用it.hasNext()进行检测。如果不调用，且下一条记录无效，抛出NoSuchElementException异常。

**案例**

~~~java
/**
 * @author
 * 遍历这个集合的所有元素，使用迭代器Iterator接口
 * 内部方法：hashNext()和next()
 */
public class Base02 {

    @Test
    public void test01(){
        Collection coll = new ArrayList<>();
        coll.add(123);
        coll.add("789");
        coll.add(new String("tom"));
        coll.add(new Person("张三",20));
        coll.add(false);

        Iterator iterator = coll.iterator();

//        //方式一：不推荐
//        System.out.println(iterator.next());
//        System.out.println(iterator.next());
//        System.out.println(iterator.next());
//        System.out.println(iterator.next());
//        System.out.println(iterator.next());
//        System.out.println(iterator.next());
//        //抛异常
//        System.out.println(iterator.next());

//        //方式二：不推荐
//        for (int i = 0; i < coll.size(); i++) {
//            System.out.println(iterator.next());
//        }
        //方式三：推荐
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}
结果：
123
789
tom
Person{name='张三', age=20}
false
~~~

解释：这里创建了一个迭代器对象来接收coll的所有数据，根据while循环进行迭代（依次判断是否有数据）数据，有的话就输出出来。

**总结：**it.hasNext()首先是指这个集合的第一个元素之前，第一次判断就是集合的第一个元素是否存在，存在就输出第一个元素，依次输出，当到达最后一个元素的时候，指向下一个为空，就结束了。

**迭代器的错误方式案例**

~~~java
/**
 * @author
 *
 * 迭代器的错误方式
 */
public class Base03 {

    @Test
    public void test01(){
        Collection coll = new ArrayList<>();
        coll.add(123);
        coll.add("789");
        coll.add(new String("tom"));
        coll.add(new Person("张三",20));
        coll.add(false);

        //方式一
        Iterator iterator = coll.iterator();
        if((iterator.next())!=null){
            System.out.println(iterator.next());
        }

        //方式二：
        while (coll.iterator().hasNext()){
            System.out.println(coll.iterator().next());
        }
    }
}
结果：
789
张三
异常
    
结果：
123
123
...
123
~~~

解释：错误方式一：判断这里从第二个开始判断，第一个就直接跳过，输出第二个，但是到后面就是直接抛异常；错误方式二：while循环里面的coll.iterator()是创建了一个新的对象，导致了他每次都是循环输出第一个元素，而且还是一个死循环。**集合对象每个调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前**。

**Iterator中的移除方法**

- Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法。
- 如果还没有调用next()或者上一次调用next方法之后已经调用了remove方法，在调用remove都会报IllegalStateException异常。

~~~java
/**
 * @author 
 */
public class Base04 {

    @Test
    public void Test01(){
        Collection coll = new ArrayList<>();
        coll.add(123);
        coll.add("789");
        coll.add(new String("tom"));
        coll.add(new Person("张三",20));
        coll.add(false);

        Iterator iterator = coll.iterator();
        while (iterator.hasNext()){
            //iterator.remove();不能这样写，因为这里的数据不存在
            Object obj = iterator.next();
            if(obj.equals("tom")){
                iterator.remove();
                //iterator.remove();这里不能再次删除，因为已经删除掉了
            }
        }
        //因为之前操作了coll这里面的数据，所以必须重新创建一个Iterator对象进行输出
        iterator = coll.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}
结果：
123
789
Person{name='张三', age=20}
false
~~~

解释：这里的remove和集合的remove方法不同，这里是将集合的数据放在一个容器里面，再进行移除，之后又赋值给集合中，所以下面要重新创建一个迭代器对象打印输出。

**for的拓展：**

~~~java
/**
 * @author
 * 数组赋值问题
 */
public class Base05 {

    public static void main(String[] args) {
        String[] strings = {"aa", "bb", "cc"};

        //方式一：普通for循环赋值
        for (int i = 0; i < strings.length; i++) {
            strings[i] = "DD";
        }

        //方式二：增强for循环赋值,这里的意思是将这个数组，赋值给s，数组原来的数据没有改变
        for (String s : strings) {
            s ="GG";
        }
		//根据数组的长度进行遍历赋值
        for (int i = 0; i < strings.length; i++) {
            System.out.println(strings[i]);
        }
    }
}
结果：
DD
DD
DD
~~~

解释：使用增强for循环其实就是将原来的数组赋值给了一个新的，新的里面进行操作，不影响原来数组的数据

### 15.3 Collection的子接口：List接口

- 鉴于java中的数组用来存储数据的局限性，我们通常使用List替代数组
- List集合类中元素有序、且可重复。集合中的每个元素都有其对应的顺序索引
- List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素
- JDK API中List的实现类常用的有：ArrayList、LinkedList和Vector
- 也被称为动态数组，因为他的长度可以变化

**ArrayList、LinkedList和Vector的异同：**

- 同：三个类都是实现了List接口，存储数据的特点相同：存储有序、可重复的数据
- 异
  - ArrayList：作为List接口的主要实现类；线程不安全、效率高；底层使用的是Object[] elementData存储
  - LinkedList：底层使用双向链表存储；对于频繁的插入和删除，效率比ArrayList高
  - Vector：作为List接口的古老实现类；线程安全、效率低；底层使用的是Object[] elementData存储

**ArrayList的源码分析：**

jdk1.7情况下：

1. ArrayList list =new ArrayList();底层创建了长度为10的Object[]数组elementData

2. list.add(123);//elementData[0] = new Integer(123);

3. list.add(11);如果此次添加数据导致底层elementData数组容量不够，则扩容。默认情况下，扩容为原来容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。

4. 开发使用中建议使用带参构造器：ArrayList list =new ArrayList(int capacity);

jdk1.8情况下：

1. ArrayList list =new ArrayList();底层Object[] elementData初始化为{}，并没有创建长度为10的数组
2. list.add(123)；第一次调用add()时，底层才创建了长度为10的数组，并且将数据放在elementData[0]里面
3. ....后续没变

小结：jdk7的ArrayList的对象创建类似于单例模式的饿汉式，而jdk8的ArrayList的对象创建类似于单例模式的懒汉式。延迟了数组的创建，节省内存。

**LinkedList源码分析：**

1. LinkedList list = new LinkedList();内部声明了Node类型的first和last属性，默认是null
2. list.add(123);将123封装到Node中，创建了Node对象
3. Node定义为：体现了双向链表的说法。

~~~java
private static class Node<E> {
        E item;
        Node<E> next;
        Node<E> prev;

        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
~~~

**Vector:**

1. jdk7和jdk8中通过Vector()构造器创建对象时，底层创建了长度为10的数组
2. 扩容方面，默认扩容为原来数组长度的2倍

**List接口方法：**

- void add(int index,Object ele):在index位置插入元素
- boolean addAll(int index,Collection )添加一个集合（批量添加）
- Object get(int index):获取指定index位置的值
- int indexOf（Object obj）：返回obj在集合中首次出现的位置
- int lastIndexOf（Object obj）：返回obj当前集合中末次出现的位置
- Object remove（int index）：移除指定index位置的元素
- Object set（int index，Object obj）：设置某个指定位置的值
- List subList（int formIndex，int toIndex）：返回指定索引范围的集合

**案例**

~~~java
/**
 * @author 
 * 根据索引和数值删除数据
 */
public class TestList01 {

    public static void main(String[] args) {
        ArrayList list = new ArrayList();
        list.add(1);
        list.add(2);
        list.add(3);
        updateList(list);
        System.out.println(list);
    }
    public static void updateList(List list){
        list.remove(2);
        list.remove(new Integer(2));
    }
}
结果：
[1]
~~~

解释：第一个remove是根据索引来删除，下标从0开始；第二个是查找对象并且删除。

### 15.4 Collection的子接口：Set接口（HashSet、LinkedSet和TreeSet）

#### 15.4.1 HashSet

- HashSet是Set接口的典型实现，大多数时候使用Set集合时都使用这个实现类。
- HashSet按Hash算法来存储集合中的元素，因此具有很好的存取、查找、删除性能。
- HashSet具有以下特点：
  - 数据不可重复
  - 不能保证元素的排列顺序
  - HashSet不是线程安全的
  - 集合元素可以是null
- HashSet判断两个集合元素相等的标准：两个对象通过HashCode()方法比较相等，并且两个对象equals()方法返回值也相等。
- 对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode（Object obj）方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”。
- Set没有定义额外的新方法，使用的是Collection中声明过的方法。

**案例**

~~~java
/**
 * @author
 * 1.Set接口的框架：
 * Collection接口：单列集合，用来存储一个一个的对象
 *      Set接口：存储无序的、不可重复的数据  ====>高中讲的集合
 *      HashSet:作为Set接口的主要实现类：线程不安全，可以存储null值
 *      LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历
 *      treeSet：可以按照添加对象的指定属性进行排序
 */
public class SetTest {

    // 1.无序性：不等于随机性。存储的数据在底层数组中并非按照数组的索引的顺序添加，而是根据数据的哈希值进行存放

    //2.不可重复性：数组的数据值不可以重复,保证添加的元素按照equals()方法判断时，不能返回true

    /*3.添加元素的过程：HashSet为例：
        向HashSet中添加元素a，首先调用元素a类的hashCode方法，计算出哈希值，然后通过某种算法计算在HashSet的底层的位置
        （就是索引位置），之后判断此位置上面是否有元素，
        此位置上面没有元素：那么该元素添加成功   --->情况1
        此位之上面有元素b（或者以链表形式存在多个元素），则比较元素a与元素b的哈希值
            如果hash值不相同，则元素a添加成功   --->情况2
            如果hash值相同，进而需要调用元素a所在类的equals()方法
                equals()返回true，元素a添加失败
                equals()返回false，则元素a添加成功 --->情况3

        对于添加成功的情况2和情况3而言：元素a与存在指定索引位置上数据以链表的方式存储
            jdk 7：元素a放在数组中，指向原来的元素
            jdk 8：原来的元素在数组中，指向元素a
            总结：七上八下
    */

    @Test
    public  void setTest1() {
       Set set = new HashSet();
       set.add(123);
       set.add(456);
       set.add(456);
       set.add(new User("tom",12));
       set.add(new User("tom",12));
       set.add("123");
		//使用迭代器遍历数据
        Iterator iterator = set.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}
结果：
123
456
User{name='tom', age=12}
123
User{name='tom', age=12}
~~~

**解释**：set里面的值是根据hashCode来存放的，User类重写了equals()方法，如果重写了hashCode方法就回去判断这两个对象的哈希值是否相等，就可以去掉重复的对象，但是这里并没有重写hashCode方法，所以此时这里只是调用了equals()方法，判断的是对象名和地址，因为地址不一致(或者说这是两个新的对象)，所以这两个对象不是重复的。

**底层**：底层是数组+链表，初始的容量为16，当使用率超过0.75，（16*0.75 = 12）就会扩大为原来的2倍。（16扩大为32、64、128....等）。

**拓展**：为什么eclipse或者是idea重写hashCode()有31这个数字？

- 选择系数的时候选择尽量大的系数。因为计算出来的hash地址越大，所谓的”冲突“就越少，查找起来效率也提高
- 并且31只占5bit（2^5-1），相乘造成的数据溢出概率较小
- 31可以有1*31==（i<<5）-1来表示，现在很多虚拟机里面都有做相关优化(提高算法效率)
- 31是素数，素数的作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有1来整除（减少冲突）

**总结：**向set对象添加数据的时候，其所在的类一定要重写hashCode()方法和equals()方法。

**重写hashCode()方法的基本原则**

- 在程序运行时，同一个对象调用hashCode()方法应该返回相同的值。
- 当两个对象的equals()方法比较返回true时，这两个对象的hashCode()方法的返回值也应该相等。
- 对象中用作equals()方法比较Field，都应该从计算hashCode值开始。

#### 15.4.2 LinkedHashSet

- LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据
- 对于频繁的遍历操作，LinkedHashSet效率高于HashSet

#### 15.4.3 TreeSet

- 在TreeSet添加的数据，数据的类型必须一致
- 两种排序方式: **自然排序**（实现Comparable接口）和**定制排序**（Comparator）
  - 自然排序：是根据数据自动进行排序，默认是升序
  - 定制排序：是根据数据的类型去重写compareTo()方法进行排序
- 自然排序中，比较两个对象是否相同标准为：compareTo()返回0，而不再是equals()方法

**自然排序案例**

~~~java
/**
 * @author
 */
public class User implements Comparable{
    private String name;
    private Integer age;

    public User() {
    }
    public User(String name, Integer age) {
        this.name = name;
        this.age = age;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Integer getAge() {
        return age;
    }
    public void setAge(Integer age) {
        this.age = age;
    }
    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
    @Override
    public boolean equals(Object o) {
        System.out.println("equals....");
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        User user = (User) o;
        return Objects.equals(name, user.name) &&
                Objects.equals(age, user.age);
    }
    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
    //按照姓名从小到大排序
    @Override
    public int compareTo(Object o) {
        if(o instanceof User){
            User user = (User)o;
            int compareTo= this.name.compareTo(user.name);
            if(compareTo!=0){
                return compareTo;
            }else{
                return Integer.compare(this.age,user.age);
            }
        }else {
            throw new RuntimeException("输入的类型不匹配");
        }
    }
}
//测试类
@Test
    public void test02(){
        Set set = new TreeSet();
        set.add(new User("jack",123));
        set.add(new User("rose",456));
        set.add(new User("Tom",13));
        set.add(new User("lucy",23));
        set.add(new User("Lily",3));
        set.add(new User("Lily",55));

        Iterator iterator = set.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
结果：
User{name='Lily', age=3}
User{name='Lily', age=55}
User{name='Tom', age=13}
User{name='jack', age=123}
User{name='lucy', age=23}
User{name='rose', age=456}
~~~

**解释：**当User类实现CompareTo接口后，重写排序方法，首先是去判断数据是否重复，之后进行排序。排序了两个参数name和age，而且返回的数据不是true或者false，而是0或者其他数字，当返回值为0的时候，系统默认这两个数据是重复的，可能会删除一条数据。

**定制排序案例**

~~~java
@Test
    public void test03() {

        Comparator comparator = new Comparator() {
            //按照年龄从小到大排序
            @Override
            public int compare(Object o1, Object o2) {
                if (o1 instanceof User && o2 instanceof User) {
                    User user = (User) o1;
                    User user1 = (User) o2;
                    return Integer.compare(user.getAge(), user1.getAge());
                } else {
                    throw new RuntimeException("输入的类型不匹配");
                }
            }
        };
        Set set = new TreeSet(comparator);
        set.add(new User("jack", 123));
        set.add(new User("rose", 456));
        set.add(new User("Tom", 13));
        set.add(new User("lucy", 23));
        set.add(new User("Lily", 333));
        set.add(new User("Lily", 55));

        Iterator iterator = set.iterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }
结果：
User{name='Tom', age=13}
User{name='lucy', age=23}
User{name='Lily', age=55}
User{name='jack', age=123}
User{name='Lily', age=333}
User{name='rose', age=456}
~~~

**解释：**当创建一个Tree对象，并且添加定制排序的时候，系统会调用自己写好的定制排序方法进行排序。

**测试案例**

~~~java
/**
 * @author
 */
public class Employee implements Comparable{
    private String name;
    private int age;
    private MyDate myDate;

    public Employee() {
    }

    public Employee(String name, int age, MyDate myDate) {
        this.name = name;
        this.age = age;
        this.myDate = myDate;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public MyDate getMyDate() {
        return myDate;
    }

    public void setMyDate(MyDate myDate) {
        this.myDate = myDate;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Employee employee = (Employee) o;
        return age == employee.age &&
                Objects.equals(name, employee.name) &&
                Objects.equals(myDate, employee.myDate);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age, myDate);
    }

    @Override
    public String toString() {
        return "Employee{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", myDate=" + myDate +
                '}';
    }

    //根据name进行排序
    @Override
    public int compareTo(Object o) {
        if(o instanceof Employee){
            Employee employee = (Employee) o;
            return this.name.compareTo(employee.name);
        }else {
            throw new RuntimeException("数据类型不匹配");
        }
    }
}
/**
 * @author
 */
public class MyDate {
    private String year;
    private String month;
    private String date;

    public MyDate(String year,String month,String date){
        this.year = year;
        this.month = month;
        this.date = date;
    }

    public String getYear() {
        return year;
    }

    public void setYear(String year) {
        this.year = year;
    }

    public String getMonth() {
        return month;
    }

    public void setMonth(String month) {
        this.month = month;
    }

    public String getDate() {
        return date;
    }

    public void setDate(String date) {
        this.date = date;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        MyDate myDate = (MyDate) o;
        return Objects.equals(year, myDate.year) &&
                Objects.equals(month, myDate.month) &&
                Objects.equals(date, myDate.date);
    }

    @Override
    public int hashCode() {
        return Objects.hash(year, month, date);
    }

    @Override
    public String toString() {
        return "MyDate{" +
                "year='" + year + '\'' +
                ", month='" + month + '\'' +
                ", date='" + date + '\'' +
                '}';
    }
}
/**
 * @author
 */
public class Test {

    public static void main(String[] args) {

        Employee employee1 = new Employee("lucy", 21, new MyDate("2020", "1", "1"));
        Employee employee2 = new Employee("Tom", 22, new MyDate("2021", "2", "1"));
        Employee employee3 = new Employee("Tim", 33, new MyDate("2021", "2", "5"));
        Employee employee4 = new Employee("Jerry", 45, new MyDate("2027", "1", "1"));
        Employee employee5 = new Employee("Lucy", 20, new MyDate("2028", "5", "1"));
        Employee employee6 = new Employee("Lucy", 48, new MyDate("2029", "6", "1"));


        //定制排序
        Comparator comparator = new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                if(o1 instanceof Employee && o2 instanceof Employee){
                    Employee employee = (Employee) o1;
                    Employee employee1 = (Employee) o2;

                    MyDate oo1 = employee.getMyDate();
                    MyDate oo2 = employee1.getMyDate();
                    //方式一：逐个判断
//                    int minusYear =oo1.getYear().compareTo(oo2.getYear());
//                    if(minusYear!=0){
//                        return minusYear;
//                    }
//                    int minusMonth = oo1.getMonth().compareTo(oo2.getMonth());
//                    if(minusMonth!=0){
//                        return minusMonth;
//                    }
//                    return (int) (Long.valueOf(oo1.getDate()) - Long.valueOf(oo2.getDate()));
                    //方式二：转换为字符串
                    return oo1.toString().compareTo(oo2.toString());
                }
                return 0;
            }
        };

        Set set = new TreeSet(comparator);
        set.add(employee1);
        set.add(employee2);
        set.add(employee3);
        set.add(employee4);
        set.add(employee5);
        set.add(employee6);

        Iterator iterator = set.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}
结果：
Employee{name='lucy', age=21, myDate=MyDate{year='2020', month='1', date='1'}}
Employee{name='Tom', age=22, myDate=MyDate{year='2021', month='2', date='1'}}
Employee{name='Tim', age=33, myDate=MyDate{year='2021', month='2', date='5'}}
Employee{name='Jerry', age=45, myDate=MyDate{year='2027', month='1', date='1'}}
Employee{name='Lucy', age=20, myDate=MyDate{year='2028', month='5', date='1'}}
Employee{name='Lucy', age=48, myDate=MyDate{year='2029', month='6', date='1'}}
~~~

**解释：**对象进行排序，使用了两种排序方式，自动排序和定制排序。

**Set判断重复值思路**：首先去判断对象的哈希值是否相等（hashCode()方法），再去判断对象是否相同（使用equals()方法判断对象名和地址是否相等）。

## 16.Map接口

双列数据，存储key-value对的数据，类似于高中学习的函数（y = f（x））;

**Map理解：**

1. Map中的key是无序、不可重复的，使用Set存储数据。 -->key所在的类要重写equals()和hashCode()方法（如果是TreeMap，就要用自动排序和定制排序了）
2. Map中的value是无序、可重复的，使用Collection存储数据。 ---->value所在的类要去重写equals()方法。
3. 一个键值对：key-value构成一个entry对象
4. Map中的entry是无序、不可重复的，使用Set存储

**Map的实现类：**

- HashMap:作为Map的主要实现类；线程不安全，效率高；可以存储为null的key或者value（底层是数组+链表（jdk7及之前），数组+链表+红黑树（jdk8））
  - LinkedHashMap(HashMap的子类): 保证在原有的Map基础上，可以按照添加的顺序进行遍历。原因：在原有的HashMap底层结构上添加一对指针，指向前一个元素和后一个元素。对于频繁的遍历操作，此类执行效率高于HashMap
- TreeMap:保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序获定制排序。底层使用的是红黑树。
- Hashtable:作为古老实现类；线程安全，效率低；不能存储为null的key或者value
  - Properties：常用来处理配置文件。key和value都是String类型。

### 16.1 HashMap类：

#### 1.1 HashMap底层实现

**jdk7为例底层实现原理：**

HashMap map = new HashMap();

在实例化以后，底层创建了长度是16的一维数组Entry[] table；

map.put(key1,value1);

首先调用key1所在类的hashCode()方法计算出key1在Entry中存放的位置上。判断该位置是否有数据：

​		没有数据：添加成功    --->情况1

​		有数据：说明此位置上有一个或者多个数据（以链表的方式存在），比较key1与一个或者多个数据的哈希值：

​				如果key1的哈希值与已经存在的数据的哈希值都不相同，添加成功    --->情况2

​				如果key1的哈希值与已经存在的数据的哈希值相同，继续比较：调用equals()方法进行比较

​						如果equals()方法返回false：数据添加成功 --->情况3

​						如果equals()方法返回true：替换掉原来的value

补充：情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。

在不断添加过程中，会涉及到扩容问题,当超出数组的临界值并且存放的位置非空时进行扩容，默认的扩容方式：扩容为原来的2倍，并将原有的数据复制过来。

**jdk8 与jdk7在底层实现方面的不同：**

1. new HashMap();底层没有创建一个长度为16的数组

2. jdk 8 底层的数组是Node[],而不是Entry[]

3. 首次添加数据的时候才会创建长度为16的数组

4. jdk7的底层结构：数组+链表;   jdk 8的底层结构：数组+链表+红黑树

   当数组某一个索引位置上的元素以链表形式存在的数据个数大于8并且当前数组的长度大于64的时候，此时该索引位置上面的所有数据改为使用红黑树存储。

**HashMap源码中的重要常量**

- **DEFAULT_INITIAL_CAPACITY**:HashMap默认容量16
- **MAXIMUM_CAPACITY**:HashMap最大支持容量，2^30
- **DEFAULT_LOAD_FACTORY**:HashMap的默认加载因子：0.75
- **TREEIFY_THRESHOLD**:Bucket中链表长度大于该默认值，转化为红黑树：8
- **UNTREEIFY_THRESHOLD**:Bucket中红黑树存储的Node小于该默认值，转化为链表
- **MIN_TREEIFY_FACTORY**:桶中的Node被树化时最小的hash表容量：64。（当桶中的Node数量大到需要变成红黑树时，若hash表容量小于MIN_TREEIFY_FACTORY的时候，此时应该执行resize扩容操作这个MIN_TREEIFY_FACTORY的值至少是TREEIFY_THRESHOLD的4倍）
- **table**:存储元素的数组，总数是2的n次幂
- **entrySet**:存储具体元素的值
- **size:HashMap**：存放键值对的数量
- **modCount**:HashMap扩容的结构和改变的次数
- **threshold**:扩容的临界值，容量*填充因子：16乘以0.75=12
- **loadFactor**:填充因子

**Map中常用的方法**

- Object put(Object key,Object value):将指定key-value添加到（或者修改）当前map对象中
- void putAll(Map m):将m中的所有key-value对存放到当前map中
- Object remove(Object key):移除指定key和key-value对，并且返回value
- void clear():清空当前map中的所有数据
- Object get(Object key):通过key获取value
- boolean containsKey(Object key): 判断key是否存在当前map中
- boolean containsValue(Object value):判断value是否在当前map中
- int size():返回map中key-value的个数
- boolean isEmpty():判断map是否为空
- boolean equals(Object obj):判断map与参数对象obj是否相等
- Set keySet():返回map中所有的key
- Collection values():返回map中所有的value
- Set entrySet:返回map中所有key-value对构成的Set集合

**Properties**

- Properties是Hashtable的子类，该对象用于处理属性文件
- 由于属性文件里的key、value都是字符串类型，所以Properties里的key、value都是字符串类型
- 存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法

**Properties案例**

~~~java
/**
 * @author
 */
public class HashMap {
    public static void main(String[] args) throws Exception {
        Properties properties = new Properties();
        FileInputStream fileInputStream = new FileInputStream("jdbc.properties");
        //加载流对应文件
        properties.load(fileInputStream);
        Object name = properties.get("name");
        Object password = properties.get("password1");
		//通过键打印值
        System.out.println(name);
        System.out.println(password);
        //关闭流
        fileInputStream.close();
    }
}
结果：
tom
123456
~~~

**解释：**根据文件流获得本项目下的jdbc.properties文件，然后使用properties加载这个流的对象，通过properties对应的get方法获取文件中的数值。

### 16.2 Collections工具类

- Collections 是一个操作Set、List和Map等集合的工具类
- Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法
- 排序的操作：（均为static方法）
  - reverse(List)：反转List中元素的排序
  - shuffle(List):对List集合元素进行随机排序
  - sort(List):根据元素自然顺序对指定List集合元素按升序排序
  - sort(List,Comparator):根据指定的Comparator产生的顺序对List集合元素进行排序
  - swap(List,int,int):将指定list集合中的i处元素与j处元素进行交换
  - Object max(Collection):根据元素的自然排序，返回给定集合中的最大元素
  - Object max(Collection,Comparator):根据Comparator的指定排序，返回给定集合中的最大元素
  - Object min(Collection):根据元素的自然排序，返回给定集合中的最小元素
  - Object min(Collection,Comparator):根据Comparator的指定排序，返回给定集合中的最小元素
  - int frequency(Collection,Object):返回指定集合中指定元素的出现次数
  - void copy(List dest,List src):将src中的内容复制到dest中
  - boolean replaceAll(List list,Object oldValue,Object newValue):使用新值替换List对象

**同步控制**

Collections类中提供了多个synchronizedXxx()方法，该方法可以使指定集合包装成线程同步集合，从而可以解决多线程并发访问集合时的线程安全问题。

- synchronizedCollection(Collection<T> c):
- synchronizedList(List<T> list):返回线程安全的list数据:
- synchronizedMap(Map<K,V> m):
- synchronizedSet(Set<T> s):
- synchronizedSortedMap(SortedMap<K,V> m):
- synchronizedSortedSet(SortedSet<T> s):

**案例**

~~~java
/**
 * @author
 * 测试Collections工具类
 */
public class CollectionsTest {

    @Test
    public void test(){
        List list = new ArrayList();
        list.add(123);
        list.add(-123);
        list.add(-3);
        list.add(333);
        list.add(1933);
        list.add(5643);

        System.out.println("正常顺序--->"+list);
        //反转
        Collections.reverse(list);
        System.out.println("反转顺序--->"+list);
        //随机排序
        Collections.shuffle(list);
        System.out.println("随机排序--->"+list);
        //升序排序
        Collections.sort(list);
        System.out.println("升序排序--->"+list);
        //交换指定位置的两个数
        Collections.swap(list,0,1);
        System.out.println("互相交换第一个和第二个位置--->"+list);

        //复制错误方式，这里的dest里面的长度的还是0，因为这里是jdk8创建一个list，他是没有设置初始长度的
//        List dest = new ArrayList(list.size());
        //正确方式
        List dest = Arrays.asList(new Object[list.size()]);
        //复制
        Collections.copy(dest,list);
        System.out.println("复制好的list--->"+dest);
    }
}
结果：
正常顺序--->[123, -123, -3, 333, 1933, 5643]
反转顺序--->[5643, 1933, 333, -3, -123, 123]
随机排序--->[1933, 5643, -3, -123, 123, 333]
升序排序--->[-123, -3, 123, 333, 1933, 5643]
互相交换第一个和第二个位置--->[-3, -123, 123, 333, 1933, 5643]
复制好的list--->[-3, -123, 123, 333, 1933, 5643]
~~~

**扩展：程序能否快速而高效地完成预定的任务，取决于是否选对了数据结构，而程序是否能够清楚而正确地把问题解决，则取决于算法。**

**总结：算法是为了解决实际问题而设计的，数据结构是算法需要处理的问题载体。**

## 17.泛型

泛型就是允许在定义类、接口时通过一个标识符表示类中的属性的类型或者是某个方法的返回值及参数类型。这个类型将在使用时（例如：继承和实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际类型的参数）。

- 泛型：标签
- 盒装的药品上面的名字，门牌号
- 泛型的设计背景：集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前不能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素类型不确定，其他部分是确定的（比如list的添加，他就不管你的类型是字符串还是整型或者是类），例如关于这个类型如何保存，如何管理等是确定的，因此此时把元素的类型看成一个参数，这个类型参数叫做泛型。Collection<E>,List<E>,ArrayList<E>,这个E就是类型参数，即泛型。

**未使用泛型的情况**

~~~java
public class Test {
    public static void main(String[] args) {
        ArrayList list = new ArrayList();
        list.add(45);
        list.add(54);
        list.add(12);
        list.add(22);
        //类型不安全
        list.add("Jack");
        for (Object o : list) {
            int o1 = (Integer) o;
            System.out.println(o1);
        }
    }
}
结果：
45
54
12
22
Exception in thread "main" java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer
	at com.zz.list.Test.main(Test.java:17)
~~~

**解释：**这里报错是因为不能够将String类型转换成Integer类型，因为ArrayList没有限制数据的类型，导致数据类型不一致，就有可能发生这种情况。

```java
public class Test {
    public static void main(String[] args) {
        ArrayList<Integer> list = new ArrayList<Integer>();
        list.add(45);
        list.add(54);
        list.add(12);
        list.add(22);
        //编译时，会去检查类型，保证数据的安全
        //list.add("Jack");
        for (Integer integer : list) {
            //避免强制转换
            int o1 = integer;
            System.out.println(o1);
        }
    }
}
结果：
45
54
12
22
```

**在集合中使用泛型注意：**

- 集合接口和集合类在jdk5以及之后都修改为可以带有泛型的结构

- 在实例化集合类时，可以指明具体的泛型类型

- 指明完以后，在集合类获取接口中凡是定义类或者接口时，内部结构（比如：方法、构造器、属性都会编程相应的类的对象）

  比如：add(E e)   ------>实例化以后：add(Integer e)

- 注意点：泛型的类型必须是类，不是基本类型。需要用到的时候也要转换为包装类型（比如：需要用到int，就要在泛型那里定义Integer）

- 如果实例化时，没有指明泛型的类型。默认为java.lang.Object类型

**自定义泛型结构：**泛型类、泛型接口；泛型方法

**例子**

~~~java
/**
 * @author
 * 自定义泛型类
 */
public class Order<T> {
    String name;
    int age;
    T orderT;
    //类的内部结构就可以使用类的泛型
    public Order(){ }
    public Order(String name,int age,T orderT){
        this.name = name;
        this.age = age;
        this.orderT = orderT;
    }
    @Override
    public String toString() {
        return "Order{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", orderT=" + orderT +
                '}';
    }
    public T getOrderT(){
        return orderT;
    }
    public void setOrderT(T OrderT){
        this.orderT = orderT;
    }
}
==========
/**
 * @author
 * 子类继承原来的泛型类
 */
public class SubOrder<T> extends Order<T> {

}
=============
/**
 * @author
 * 测试自定义泛型类
 */
public class TestOrder {
    public static void main(String[] args) {
        //未指明泛型类对象
        Order order1 = new Order();
        order1.setOrderT(13456);
        //带有类型的泛型类对象
        Order<String> order = new Order<>();
        order.setOrderT("001");
        //子类继承自定义泛型类
        SubOrder subOrder = new SubOrder();
        subOrder.setOrderT(new BigDecimal("000"));
        //带有类型的子类继承自定义泛型类
        SubOrder<Integer> integerSubOrder = new SubOrder<>();
        integerSubOrder.setOrderT(111);
    }
}
~~~

**解释：**创建泛型类的对象如果未指明泛型属于哪个类，就可以随意添加不同类型的数据（这个垃圾桶未指明存放哪类垃圾，就可以随意扔垃圾）；创建带有类型的泛型类对象，设置值的时候，就必须要根据类型来设置值（指明了这个垃圾桶只能存放可回收垃圾，就只能扔可回收的垃圾）；子类也可以继承带有泛型的类，跟前面一样也可以创建带有类型的子类对象和不带有，前提是子类也要加上“<T>”。

**注意：**

- 泛型类可能有多个参数，此时应该将多个参数放在尖括号里面（<E1,E2,E3>）;
- 泛型类的构造方法是不加尖括号的（public Order(){}）;
- 实例化后，与实例化的对象的类型要保持一致
- 泛型不同的引用不能相互赋值（可回收的垃圾桶不能扔不可回收的垃圾），尽管在编译的时候ArrayList<String>和ArrayList<Integer>是两种类型，但是，在运行时是一个ArrayList加载到JVM中
- 泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。经验：泛型要使用就一直使用。如果不用就一直不用。
- 如果泛型结构是一个接口或者抽象类，则不可创建泛型类的对象
- jdk1.7，泛型简化操作，ArrayList<String> list = new ArrayList<>();
- 泛型的指定中不能使用基本数据类型，可以使用包装类替换
- 静态方法中不能使用类的泛型（因为静态方法是在创建对象之前就已经存在，定义好了泛型，创建对象时，就不能指定类型了）
- 异常类不能是泛型的
- 不能使用new T[]；但是可以 T[] elementData = (T[])new Object[capacity]);
- 父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型：
  - 子类不保留父类的泛型：按需实现
    - 没有类型，擦除
    - 具体类型
  - 子类保留父类的泛型：
    - 全部保留
    - 部分保留
  - 结论：子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型

~~~java
class F<T1,T2>{
    //父类
}
class s1 extends F{
    //子类不保留父类，擦除
}
class s2 extends F<Integer,String>{
    //具体类型
}
class s3<T1,T2> extends F<T1,T2>{
    //子类保留父类：全部保留
}
class s4<T2> extends F<Integer,T2>{
    //部分保留
}
class s5<A,B> extends F{
    //子类不保留父类的泛型
    //擦除
    //等价于 class s5 extends F<Object,Object>{}
}
class s6<A,B> extends F<Integer,String>{
        //具体实现
}
class S7<T1,T2,A,B> extends F<T1,T2>{
    //子类保留父类的泛型
    //全部保留
}
class S8<T1,A,B> extends F<Integer,T1>{
    //部分保留
}
~~~

**泛型方法：**

- 在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系	
- 泛型方法与类是不是泛型无关
  - 可以声明为静态的。原因：泛型参数是在调用方法时确定的。并非是在实例化类确定的

**静态方法案例**

~~~java
public static <E> List<E> copyArrayList(E[] arr){
        ArrayList<E> list = new ArrayList();
        for (E e : arr) {
            list.add(e);
        }
        return list;
    }
~~~

**泛型继承问题**

~~~java
/**
 * @author
 * 泛型继承问题
 */
public class Test01 {

    /**
     * 虽然类A是类B的父类，但是G<A>和G<B>二者不具备子父类关系，二者确实并列关系
     * 补充：类A是类B的父类：A<G>是B<G>的父类
     */

    @Test
    public void test01(){
        Object obj = null;
        String str = null;
        obj = str;

        List<Object> objects = new ArrayList<>();

        List<String> strings = new ArrayList<>();
        //此时的objects和strings不具备字符类关系
        //编译不通过
        //objects = strings;

        List<Object> list1 = null;
        List<String> list2 = new ArrayList<String>();
        /*
         反证法：
         假设 list1 = list2;
         list1.add(123);导致混入了非String的数据，导致出错
         */
    }
    @Test
    public void test02(){
        AbstractList<String> list = null;
        List<String> list1 = null;
        ArrayList<String> list2 = new ArrayList<>();
        
        list1 =list;
        list = list2;
        
    }
}
~~~

**解释：**String类是Object的子类，创建此类的对象的时候可以直接执行，但是如果是执行List<String>和List<Object>的时候他们就是平级的（理解装载的容器是有关系的，但是装载的内容不同；第二种就是类型相同，装载容器(数据结构不同)AbstractList<String>、List<String>和ArrayList<String>，因为这三个数据结构是继承关系，里面的泛型是相同的，所以可以继承（例子：转载的容器不是一样的，但是装载的内容有关系）。

### 通配符的使用（？）

~~~java
/**
 * @author
 * 通配符的使用
 * ?
 */
public class Test02 {

    public static void main(String[] args) {
        List<?> list = null;
        List<String> list1 = new ArrayList<>();
        list1.add("AA");
        list1.add("sdasd");
        list1.add("abd");
        list = list1;
        //此时添加类型不可以，是因为原来的list的类型是通配符类型，将String类型的list1的数据放在list中是可以的，因为包含了String类型，
        // 但是不可以在list中添加时因为，list的类型是通配符，不知道类型，除了null，null是所有类的都可以使用的。
        //list.add("sdsa");
        //写的操作只能是写null
        list.add(null);
        //读取操作：可以进行读取操作,读取的类型是object类型
        Object o = list.get(0);
        System.out.println(o);
    }
}
结果：
AA
~~~

**解释：**对于通配符的读写操作有局限性，写的时候，是不能够添加除了null的其他数据，读取出来的数据是Object类型。

**有限制的通配符**

- <?>：允许所有泛型的引用调用
- 通配符指定上限，上限使用extends：使用时指定的类型必须是继承某个类，或者实现某个接口，即<=
- 通配符指定下限,使用时指定的类型不能小于操作的类，即>=
- 举例：
  - <? extends Number> （无穷小，Number] 只允许泛型为Number和Number子类的引用调用
  - <? super Number> [Number,无穷大) 只允许泛型为Number即Number父类的引用调用
  - <? extends Comparator> 只允许泛型为实现Comparable接口的实现类的引用过调用

**案例**

~~~java
/**
 * @author
 */
public class Test03 {

    @Test
    public void test01(){
        List<? extends Person> list = null;
        List<? super Student>  list1 = null;
        List<? extends Object> list2 = null;

        List<Student> studentList = new ArrayList<Student>();
        List<Person> personList = new ArrayList<Person>();

        list1 = studentList;
        list = personList;
        list2 = studentList;
        list2 = personList;
    }
}
~~~

**注意：**List<? extends Person>（List<? extends Object>）代表的是，负无穷到Person（Object），有上限。List<? super Student>：代表的是Student到其父类所有，有下限。

**练习案例**

~~~java
/**
 * @author
 * 泛型类
 */
public class Dao<T> {
    private Map<String, T> map = new HashMap<String, T>();
    /**
     * 保存T类型的对象在map中
     * @param id
     * @param entry
     */
    public void save(String id,T entry){
        map.put(id,entry);
    }

    /**
     * 通过map中的id获取对象
     * @param id
     * @return
     */
    public T get(String id){
         return map.get(id);
    }

    /**
     * 替换map中key为id的内容，设置为entry对象
     * @param id
     * @param entry
     */
    public void update(String id,T entry){
        map.put(id,entry);
    }

    /**
     * 返回map中所有的T对象
     * @return
     */
    public List<T> list(){
        //这种方式是错误的，因为Collection存放的数据是可重复、无序的，而List的数据是不可重复、有序的。
//        Collection<T> values = map.values();
//        return (List<T>) values;
        Collection<T> values = map.values();
        List list = new ArrayList();
        for (T value : values) {
            list.add(value);
        }
        return list;
    }

    /**
     * 删除map中key为id的value
     * @param id
     */
    public void remove(String id){
        map.remove(id);
    }
}
-------------
/**
 * @author
 * User类
 */
@Data
public class User {
    private int id;
    private int age;
    private String name;

    public User() {
    }

    public User(int id, int age, String name) {
        this.id = id;
        this.age = age;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", age=" + age +
                ", name='" + name + '\'' +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        User user = (User) o;
        return id == user.id &&
                age == user.age &&
                Objects.equals(name, user.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, age, name);
    }
}
-------------
/**
 * @author
 * 测试方法
 */
public class TestUser {

    public static void main(String[] args) {
        Dao<User> userDao = new Dao<>();

        userDao.save("001",new User(1,10,"张三"));
        userDao.save("002",new User(2,20,"李四"));
        userDao.save("003",new User(3,30,"王五"));
        userDao.save("004",new User(4,40,"赵六"));

        //删除数据
        userDao.remove("004");
        //修改数据
        userDao.update("003",new User(3,30,"王六"));
        List<User> list = userDao.list();
        list.forEach(System.out::println);
    }
}
结果：
User{id=1, age=10, name='张三'}
User{id=2, age=20, name='李四'}
User{id=3, age=30, name='王六'}
~~~

**注意：**在Dao类中，创建私有属性的时候

- 创建一个属性，就必须要写set和get方法，不然调用的时候会报错（空指向异常）；
- 创建该属性类的对象，就可以直接使用。

Dao类中返回List方法，不能够直接强制转换，因为是Collection存储数据和List的存储数据特点不同，所以需要遍历Collection中的数据放在list中。

## 18.IO流

### 18.1 File类的使用

- java.io.File类：文件和文件目录路径的抽象表现形式，与平台无关。
- File能新建、删除、重命名文件和目录，但是File不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入/输出流。
- 想要在Java程序中表示一个真实存在的文件或目录，那么必须要有一个File类的对象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录。
- File类的对象可以作为参数传递给流的构造器。

**常用构造器**

- public File(String pathname){

  ​	以pathname为路径创建File对象，可以是绝对路径也可以是相对路径，如果	

  ​	pathname是相对路径，则默认当前路径在系统属性user.dir中存储。

  - 绝对路径：是一个固定的路径，从盘符开始。
  - 相对路径：是相对于某个位置开始。

  }

- public File(String parent，String child){

  以parent为父路径，以child为子路径创建File对象。

  }

- public File(File parent，String child){

  根据一个父File对象和子文件路径创建File对象。

  }

**路径分隔符**

- 路径中的每级目录之前用一个路径分隔符隔开

- 路径分隔符与系统有关：

  - Windows和DOS系统默认使用“\”来表示
  - UNIX和URL使用“/”来表示

- Java程序支持跨平台运行，因此路径分隔符要慎用

- 为了解决这一隐患，File类提供了一个常量：

  public static final String separator；根据操作系统，动态提供分隔符

- 举例：

~~~java
File file = new File("d:\\xx\\xx.txt");
File file1 = new File("d:"+File.separator +"xx" + File.separator+"xx.txt");
File file2 = new File("d:/xx");
~~~

**常用方法**

- public String getAbsolutePath();获取绝对路径
- public String getPath();获取路径
- public String getName();获取文件名称
- public String getParent();获取上级文件目录路径。如果无，就返回null
- public long length();获取文件长度（即：字节数）。不能获取目录长度
- public long lastModified();获取最后一次的修改时间，毫秒值

**适用于文件目录**

- public String[] list();获取指定目录下的所有文件或者文件目录的名称数组
- public File[] listFiles();获取指定目录下的所有文件或者文件目录的File数组

**File类的重命名**

- public boolean renameTo(File dest);把文件重命名为指定的文件路径

**File类的判断功能**

- public boolean isDirectory();判断是否为文件目录
- public boolean isFile();判断是否为文件
- public boolean exists();判断是否存在
- public boolean canRead();判断是否可读
- public boolean canWrite();判断是否可写
- public boolean isHidden();判断是否隐藏

**File类的创建功能**

- public boolean createNewFile();创建文件，若文件在内存中存在，则不创建，返回false
- public boolean mkdir();创建文件目录。如果此文件目录存在，就不创建。若此文件目录的上层文件目录不存在，也不创建。
- public boolean mkdirs();创建文件目录。如果上层文件目录不存在，一并创建。

**注意：**如果你创建的文件目录或者文件目录没有写盘符路径。那么，默认在项目路径下。

**File类的删除功能**

- public boolean delete()：删除文件或者文件夹

**删除注意事项：**

Java中的删除不走回收站

要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录

**创建目录案例**

~~~java
/**
 * @author
 * 相对路径：相对于某个路径下，指明的路径
 * 绝对路径：包含盘符在内的文件获文件目录的路径
 */
public class Test01 {
    @Test
    public void test01(){
        //构造器1 File(String filePath)
        //相对于module
        File file = new File("hello.txt");
        //双斜杠的意思就是不和转义字符起冲突
        File file1 = new File("D:\\ideaworkspace\\base\\src\\com\\zz\\io");

        System.out.println(file);
        System.out.println(file1);

        //构造器2 File(String parentPath,String childPath)
        File file2 = new File("D:\\ideaworkspace\\base\\src\\com\\zz", "io");
        System.out.println(file2);

        //构造器3 File(File parentFile,String childPath)
        File file3 = new File(file2, "hello.txt");
        System.out.println(file3);
    }
}
结果：
hello.txt
D:\ideaworkspace\base\src\com\zz\io
D:\ideaworkspace\base\src\com\zz\io
D:\ideaworkspace\base\src\com\zz\io\hello.txt
~~~

**注意：**构造方法2和构造方法3的第一个参数其中一个是String类型，另外则是File(文件目录)类型。这里只是内存层面的对象，并不真实存在磁盘中，后续可以添加。

**获取文件目录案例**

~~~Java
@Test
    public void Test02(){
        //创建文件目录
        File file = new File("hello.txt");
        File file1 = new File("D:\\ideaworkspace\\base\\src\\com\\zz\\io\\hello1.txt");

        //相对路径
        System.out.println(file.getAbsoluteFile());
        System.out.println(file.getPath());
        System.out.println(file.getName());
        System.out.println(file.getParent());
        System.out.println(file.length());
        System.out.println(new Date(file.lastModified()));
        System.out.println("--------------------------");

        //绝对路径
        System.out.println(file1.getAbsoluteFile());
        System.out.println(file1.getPath());
        System.out.println(file1.getName());
        System.out.println(file1.getParent());
        System.out.println(file1.length());
        System.out.println(new Date(file1.lastModified()));
        System.out.println("--------------------------");

        //输出所有文件（文件目录名）
        File file2 = new File("D:\\ideaworkspace\\base");
        String[] list = file2.list();
        for (String s : list) {
            System.out.println(s);
        }
        System.out.println("--------------------------");
        //输出所有文件（绝对路径）
        File[] files = file2.listFiles();
        for (File file3 : files) {
            System.out.println(file3);
        }
    }
结果：
D:\ideaworkspace\base\hello.txt
hello.txt
hello.txt
null
0
Thu Jan 01 08:00:00 CST 1970
--------------------------
D:\ideaworkspace\base\src\com\zz\io\hello1.txt
D:\ideaworkspace\base\src\com\zz\io\hello1.txt
hello1.txt
D:\ideaworkspace\base\src\com\zz\io
0
Thu Jan 01 08:00:00 CST 1970
--------------------------
.idea
base.iml
hello
jdbc.properties
out
src
--------------------------
D:\ideaworkspace\base\.idea
D:\ideaworkspace\base\base.iml
D:\ideaworkspace\base\hello
D:\ideaworkspace\base\jdbc.properties
D:\ideaworkspace\base\out
D:\ideaworkspace\base\src
~~~

**注意：**file2.list()是一个String类型的数组，而且存储的只是目录名称，可以直接输出；file2.listFiles()是一个File类型的数组，里面的数据都是FIle类的对象，自动调用toString方法输出数据，而且输出的数据是绝对路径。

File file2 = new File("D:\\ideaworkspace\\base");这个路径必须是真实存在的，不然会报错（空指向异常）。

~~~java
 @Test
    public void test03(){
        //file文件存在
        File file = new File("hello");
        //file1文件不存在
        File file1 = new File("D:\\ideaworkspace\\base\\src\\com\\zz\\io\\hello2.txt");

        //重命名
        boolean b = file.renameTo(file1);
        System.out.println(b);
    }
结果：
true
~~~

**注意：**此时就是将file对象里面的hello文件里面的所有数据复制到file1中，之后hello这个文件消失。前提条件就是：file这个文件的路径在硬盘中存在，file1不存在硬盘中。

**File类的判断实例**

~~~java
@Test
    public void test04(){
        File file = new File("hello.txt");
        //是否是一个文件夹
        System.out.println(file.isDirectory());
        //是否是一个文件
        System.out.println(file.isFile());
        //是否存在
        System.out.println(file.exists());
        //是否能够读取
        System.out.println(file.canRead());
        //是否能够写
        System.out.println(file.canWrite());
        //是否隐藏
        System.out.println(file.isHidden());
    }
结果：
false
true
true
true
true
false
~~~

**注意：**尽量先判断是否存在，之后再执行后面的操作。

**创建硬盘中对应的文件或文件目录和删除文件案例**

~~~java
 @Test
    public void test05() throws IOException {
        //文件的创建
        File file = new File("h.txt");
        if(!file.exists()){
            file.createNewFile();
            System.out.println("创建成功");
        }else{
            file.delete();
            System.out.println("删除成功");
        }
    }
结果：
新增成功
~~~

**注意：**此时如果该文件不存在，就创建；如果存在就删除掉。

**文件目录的创建**

~~~java
@Test
    public void test06(){
        File file = new File("D:\\ideaworkspace\\base\\111\\222\\333");
        //判断文件目录是否存在
        boolean mkdir = file.mkdir();
        if(mkdir){
            System.out.println("创建成功1");
        }
        File file1 = new File("D:\\ideaworkspace\\base\\111\\222\\333");
        //判断文件目录是否存在
        boolean mkdir1 = file1.mkdirs();
        if(mkdir1){
            System.out.println("创建成功2");
        }
    }
结果：
创建成功2
~~~

**注意：** mkdir与mkdirs都是进行判断文件目录是否存在，若不存在就创建文件目录。不同点在于：

- mkdir去判断上级目录是否存在，如果上级目录不存在就不创建文件目录。

- mkdirs也是去判断上级目录是否存在，如果不存在，会把上级目录也创建。

  **总结：**当硬盘中有一个真实的文件或者目录时，创建File对象时，各个属性会显式赋值；反之，那么创建对象时，除了指定的目录和路径外，其他的属性都是取成员变量的默认值。这里并没有涉及到文件内容的读取操作，如果需要读取或者写入文件内容，必须使用IO流来完成。

### 18.2 IO流原理及流的分类

**Java IO原理**

- I/O是Input/Output的缩写，I/O技术是非常实用的技术，用于处理设备之间的数据传输。如读/写文件，网络通讯等。
- Java程序中，对于数据的输入/输出操作以“流(stream)”的方式进行
- Java.io提供各种“流”类和接口，用以获取不同种类的数据，并且通过**标准的方法**输入（read）或输出（write）数据
- 输入input：外部数据读取到程序中
- 输出output：将程序(内存)数据输出到磁盘、光盘等存储设备中

**流的分类**

- 按照操作数据单位不同：字节流（8 bit），字符流（16 bit）;字节流主要处理图片等，字符流主要处理文本。
- 按照操作流的流向不同：输入流、输出流
- 按照流的角色不同分为：节点流、处理（管道流）流

| 抽象基类 | 字节流       | 字符流 |
| -------- | ------------ | ------ |
| 输入流   | InputStream  | Reader |
| 输出流   | OutputStream | Writer |

1. Java的IO流共涉及40多个类，实际上非常规则，都是从如下4个抽象基类派生的
2. 由这四个类派生的子类名称都是以其父类名作为子类名后缀

![IO流分类图](../image/IO原理.png)



![](../image/IO流体系.png)

**main方法和其他方法中的文件路径区别案例**

~~~java
public class FileReaderWriterTest {

    public static void main(String[] args) {
        //相对于当前项目下
        File file = new File("hello.txt");
        System.out.println(file.getAbsoluteFile());

        //相对于当前Module下
        File file1 = new File("IO\\hello.txt");
        System.out.println(file1.getAbsoluteFile());
    }

    @Test
    public void testFileReader(){
        //相对于当前module下
        File file = new File("hello.txt");
    }
}
结果：
D:\ideaworkspace\base\hello.txt
D:\ideaworkspace\base\IO\hello.txt
D:\ideaworkspace\base\IO\hello.txt
~~~

**解释：**在main方法中，创建一个File对象里面的路径是相对于本项目下面的。但是在其他方法中，是相对于本module下面的。可以在main方法里面创建File对象时，添加module的路径，依然可以实现在当前module下面。

**流的体系结构：**

| 抽象基类     | 节点流(获文件流) | 缓冲流(缓冲流的一种) |
| ------------ | ---------------- | -------------------- |
| InputStream  | FileInputStream  | BufferInputStream    |
| OutputStream | FileOutputStream | BufferOutputStream   |
| Reader       | FileReader       | BufferReader         |
| Writer       | FileWriter       | BufferWriter         |

### 18.3 节点流(或者文件流)

- FileInputStream(字节流)
- FileOutputStream(字节流)
- FileReader（字符流）
- FileWriter（字符流）

**读入数据案例**

**思路：**

1. 创建File类对象，指明硬盘存在的文件
2. 创建管道流
3. 数据读入
4. **关闭流**

~~~Java
public class FileReaderWriterTest {
    @Test
    public void fileReader(){
        FileReader fileReader = null;
       try{
           //1.创建File对象
           File file = new File("hello.txt");
           //2.创建管道流
            fileReader= new FileReader(file);
           //3.数据读入
           //read():返回读入的一个字符。如果达到文件末尾，返回值为-1
           //方式一：
//        int read = fileReader.read();
//        while (read != -1) {
//            System.out.print((char) read);
//            read = fileReader.read();
//        }
           //方式二：
           int data;
           while ((data=fileReader.read())!=-1){
               System.out.println((char) data);
           }
       }catch (IOException e){
          e.printStackTrace();
       }finally {
           //1.关闭流操作
           //方式一：
//           try {
//               if (fileReader!=null){
//                   fileReader.close();
//               }
//           } catch (IOException e) {
//               e.printStackTrace();
//           }
           //方式二：
           if(fileReader!=null){
               try {
                   fileReader.close();
               } catch (IOException e) {
                   e.printStackTrace();
               }
           }
       }
    }
}
结果：
hello world
~~~

**注意：**

- 此时是将硬盘中的内容读取到内存中,file对象中的文件路径是相对路径，此时这里文件路径必须存在，否则会报错FileNotFoundException。
- 读取file使用的是read()方法，每次都只会读取一个字符，若文件达到末尾，读取返回-1，输出的时候需要转换一下，因为正常读取是对应ascall码而不是字符，**最后不要忘记关闭流了**。
- 此时这里使用try-catch-finally主要是为了保证流的关闭，不然会造成内存资源的浪费。

**使用read(char[] cbuf)方法读入数据案例**

~~~java
@Test
    public void fileReader01(){
        FileReader fr = null;
        try {
            //1.File实例化
            File file = new File("hello.txt");
            //2.创建管道流
            fr = new FileReader(file);
            //3.读入数据，这里创建一个字符数组，保证一次读入5个字符
            char[] cbuf = new char[5];
            int len;
            //方式一
            //错误方式
//        while ((len =fr.read(cbuf))!=-1){
//            for (int i = 0; i < cbuf.length; i++) {
//                System.out.print(cbuf[i]);
//            }
//        }
            //正确方式：
            while ((len = fr.read(cbuf))!=-1){
    //            for (int i = 0; i < len; i++) {
    //                System.out.print(cbuf[i]);
    //            }

                //方式二：
                //错误方式
    //        String s = new String(cbuf);
    //        System.out.println(s);
                //正确方式
                String s = new String(cbuf,0,len);
                System.out.print(s);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //4.关闭流
            if(fr!=null){
                try {
                    fr.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
结果：
hello world
~~~

**注意：**

- 仍使用try-catch-finally抛异常，保证系统中流的关闭
- 使用带参数的读入方法，可能导致数据输出问题，需要自定义一个长度来规范输出数据
- 不要忘记关闭流

**内存中写出数据到磁盘中的文件案例**

~~~java
@Test
    public void fileWriteTest(){
        FileWriter fw = null;
        try {
            //1.File实例化
            File file = new File("hello1.txt");
            //2.流的实例化
            fw = new FileWriter(file,true);
            //3.写出数据
            fw.write("i like java \n");
            fw.write("you like java");
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if(fw !=null){
                //4.关闭流
                try {
                    fw.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
~~~

**注意：**

- 输出操作，对应的File可以不存在。并且不会报异常，因为是输出到file文件中的，不存在就会自动创建一个在当前module下面
- File在硬盘中的文件如果不存在，在输出的过程中，会自动创建文件
- File对应的文件存在如果：
  - 如果流使用的构造器是FileWriter(file,false)或者是FileWriter(file):此时就是对原有文件的**内容**进行覆盖操作;
  - 如果流使用的构造器是FileWriter(file,true):此时就是对源文件**内容**进行**添加**操作。

**文档输入输出整合案例**

~~~java
@Test
    public void fileReaderWriterTest(){
        FileReader fr = null;
        FileWriter fw = null;
        try {
            //1.File实例化
            File file1 = new File("hello.txt");
            File file2 = new File("hello2.txt");
            
            //不能使用字符流来处理图片等字节流数据
            //File srcFile = new File("hello.txt");
            //File destFile = new File("hello2.txt");
            
            //2.输入输出流实例化
            fr = new FileReader(file1);
            fw = new FileWriter(file2);
            //3.写入写出数据
            char[] cbuf = new char[5];
            int len;
            //判断是否是最后一个字符
            while ((len =fr.read(cbuf))!=-1){
                //写出数据
                fw.write(cbuf,0,len);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //4.关闭输入输出流
            
//            //方式一：
//            try {
//                if(fw!=null){
//                    fw.close();
//                }
//            } catch (IOException e) {
//                e.printStackTrace();
//            } finally {
//                try {
//                    if(fr!=null){
//                        fr.close();
//                    }
//                } catch (IOException e) {
//                    e.printStackTrace();
//                }
//            }
            //方式二：
            try {
                if(fw!=null){
                    fw.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                if(fr!=null){
                    fr.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
~~~

**注意：**

- 不能使用字符流来处理图片等字节流数据
- 关闭输入输出流的时候方式一和方式二都可以
- 写出数据的时候需要使用write(cbuf,0,len)方法，添加开始索引和数据长度
- 不要忘记关闭流

**图片复制案例1**

~~~java
@Test
    public void fileInputOutputStreamTest(){
        FileInputStream fis = null;
        FileOutputStream fos = null;
        try {
            //1.实例化File
            File file = new File("1111.jpg");
            File file1 = new File("2222.jpg");
            //2.创建输入输出流(节点流)
            fis = new FileInputStream(file);
            fos = new FileOutputStream(file1);
            //3.读入与写出数据
            byte[] bytes = new byte[5];
            int len;
            //判断读入是否为最后一个字节
            while ((len=fis.read(bytes))!=-1){
                //写出所有的字节
                fos.write(bytes,0,len);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //4.关闭流
            try {
                if(fos!=null){
                    fos.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                if(fis!=null){
                    fis.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
~~~

**图片复制案例2**

~~~Java
/**
     * 复制文件
     * @param srcPath
     * @param destPath
     */
    public void copyFile(String srcPath,String destPath){
        FileInputStream fis = null;
        FileOutputStream fos = null;
        try {
            //1.实例化File
            File file = new File(srcPath);
            File file1 = new File(destPath);
            //2.创建输入输出流
            fis = new FileInputStream(file);
            fos = new FileOutputStream(file1);
            //3.写入与写出数据，复制过程
            byte[] bytes = new byte[5];
            int len;
            //判断读入是否为最后一个字节
            while ((len=fis.read(bytes))!=-1){
                //写出所有的字节
                fos.write(bytes,0,len);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //4.关闭流
            try {
                if(fos!=null){
                    fos.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                if(fis!=null){
                    fis.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }

        }
    }
------------------------
@Test
    public void copyFileTest(){
        //开始时间
        long startTime = System.currentTimeMillis();
        String srcPath = "1111.jpg";
        String destPath = "3333.jpg";

        copyFile(srcPath,destPath);
        //结束时间
        long endTime = System.currentTimeMillis();
        System.out.println("复制完成时间："+(endTime-startTime));
    }
结果：
复制完成时间：6
~~~

**注意：**

- 使用字节流处理文本文件可能出现乱码
- 复制方法里面的字节数组byte[] bytes = new byte[5];长度可以设置，最大是1024；但是数组长度最大会导致执行时间增加
- 方法里面不要忘记关闭流

**结论：**

- 对于文本文件(.txt,.java,.c,.cpp),使用字符流处理
- 对于非文本文件(.jpg,.mp3,.mp4,.avi,.doc,.ppt,...),使用字节流处理；文本文件也可以使用字节流进行复制

### 18.4 缓冲流（处理流之一或者叫做管道流之一）

- **缓冲流：**
  - BufferedInputStream
  - BufferedOutputStream
  - BufferedReader
  - BufferedWriter
- **作用：**提供流的读取、写入的速度
- 提高读写速度的原因：内部提供一个缓冲区
-  处理流，就是“套接”在已有的流的基础上，不一定是字节流，还有可能是其他的流

**思路：**

- 实例化File
- 实例化节点流
- 实例化缓冲流（处理流）
- 读写数据
- 关闭流

**非文本文件处理(缓冲)流案例**

~~~java
/**
 * @author
 * 测试处理流
 */
public class BufferedTest {

    @Test
    public void BufferedStreamTest(){
        BufferedInputStream bis = null;
        BufferedOutputStream bos = null;
        try {
            //1.实例化File
            File srcFile = new File("1111.jpg");
            File destFile = new File("4444.jpg");
            //2.实例化节点流
            FileInputStream fis = new FileInputStream(srcFile);
            FileOutputStream fos = new FileOutputStream(destFile);
            //3.实例化处理流
            bis = new BufferedInputStream(fis);
            bos = new BufferedOutputStream(fos);
            //4.读写数据
            byte[] bytes = new byte[5];
            int len;
            while ((len=bis.read(bytes))!=-1){
                bos.write(bytes,0,len);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //5.关闭流
            //先关闭外层流，再关闭内层流
            // 外层流关闭之后，就可以省略内层流的关闭操作
            try {
                if(bos!=null){
                    bos.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                if(bis!=null){
                    bis.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
~~~

**注意：**

- 实例化File的时候，需要被读入的文件必须存在(File srcFile = new File("1111.jpg");)
- 使用缓冲流(处理流)的时候，参数是实例化File对象
- 读写的时候使用的是外层流对象（缓冲流对象）进行处理
- 不要忘记关闭流，并且关闭流的时候，只需要关闭外层的处理流，内层的节点流会自动关闭

**处理文本流**

~~~java
 @Test
    public void bufferedReaderWriterTest() {
        BufferedReader br = null;
        BufferedWriter bw = null;
        try {
            //文本处理流
            br = new BufferedReader(new FileReader(new File("hello.txt")));
            bw = new BufferedWriter(new FileWriter(new File("hello3.txt")));

            //读写数据
            //方式一：
//            char[] cbuf = new char[1024];
//            int len;
//            while ((len=br.read(cbuf))!=-1){
//                //读取数据，不会换行
//                bw.write(cbuf,0,len);
            //bw.flush();清空缓冲流
//                bw.newLine();//换行
//            }
            //方式二：
            String data;
            while ((data = br.readLine()) != null) {
                //写出数据不会换行
                bw.write(data);
                //换行
                bw.newLine();
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //关闭流
            if (bw != null) {
                try {
                    bw.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (br != null) {
                try {
                    br.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
~~~

**注意：**

- 方式一依然使用char数组进行进行读写的限制，方式二使用String类的readLine()方法(一次读一行)进行读写，差别暂时不知道
- 写出方法使用write()进行写出，但是不会换行，使用newLine进行换行，或者在write()方法里面自动添加换行符
- 可以使用写出流中的flush()方法清空输出流
- 不要忘记关闭流

**练习题**

~~~java
/**
     * 实现图片的加密
     */
    @Test
    public void test(){
        BufferedInputStream bis = null;
        BufferedOutputStream bos = null;
        try {
            //创建流
            bis = new BufferedInputStream(new FileInputStream(new File("1111.jpg")));
            bos = new BufferedOutputStream(new FileOutputStream(new File("1111secret.jpg")));

            //读写
            byte[] buffer = new byte[8];
            int len;
            while ((len =bis.read(buffer))!=-1){
                //加密：
                //方式一：无法进行修改
    //            for (byte b : buffer) {
    //                b = (byte) (b^5);
    //            }
                //方式二：
                for (int i = 0; i < buffer.length; i++) {
                    buffer[i] = (byte) (buffer[i]^5);
                }
                bos.write(buffer,0,len);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //关闭流
            if(bos!=null){
                try {
                    bos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(bis!=null){
                try {
                    bis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
~~~

**图片解密案例**

~~~java
	/**
     * 实现图片的解密
     */
    @Test
    public void test(){
        BufferedInputStream bis = null;
        BufferedOutputStream bos = null;
        try {
            //创建流
            bis = new BufferedInputStream(new FileInputStream(new File("1111secret.jpg")));
            bos = new BufferedOutputStream(new FileOutputStream(new File("22222.jpg")));

            //读写
            byte[] buffer = new byte[8];
            int len;
            while ((len =bis.read(buffer))!=-1){
                //加密：
                //方式一：无法进行修改
    //            for (byte b : buffer) {
    //                b = (byte) (b^5);
    //            }
                //方式二：
                for (int i = 0; i < buffer.length; i++) {
                    buffer[i] = (byte) (buffer[i]^5);
                }
                bos.write(buffer,0,len);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //关闭流
            if(bos!=null){
                try {
                    bos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(bis!=null){
                try {
                    bis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
~~~

**注意：**

- 图片加密和解密都是使用字节流和处理流进行操作。
- 加密的时候图片是可以看的，加密之后就不能看；解密是和加密相互的
- (buffer[i]^5)这种方式进行加密，同时也可以使用这种方式进行解密（水能载舟，亦能覆舟）
- 加密的时候不要使用增强for循环进行字节加密，因为增强for循环是将原来的数据赋值给了一个新的对象，原来的数据没有变化，达不到加密效果

**练习2：获取文本上字符出现的次数**

~~~java
	/**
     * 获取文本上字符出现的次数
     * 存放在map中
     */
    @Test
    public void test02(){
        BufferedReader br = null;
        BufferedWriter bw = null;
        try {
            //需要读取的文件
            File file = new File("hello2.txt");
            File file1 = new File("hello3.txt");
            //创建一个map，存放不同的键值对
            Map<Character, Integer> map = new HashMap<>();

            //存放数据
            br = new BufferedReader(new FileReader(file));
            int data;
            while ((data = br.read()) != -1) {
                char c = (char) data;
                if (map.get(c) == null) {
                    map.put(c, 1);
                } else {
                    map.put(c, map.get(c) + 1);
                }
            }
            //写出新文件中
            bw = new BufferedWriter(new FileWriter(file1));
            Set<Map.Entry<Character, Integer>> entrySet = map.entrySet();
            for (Map.Entry<Character, Integer> entry : entrySet) {
                switch (entry.getKey()){
                    case ' ':
                        bw.write("空格="+entry.getValue());
                        break;
                    case '\t':
                        bw.write("tab键="+entry.getValue());
                        break;
                    case '\r':
                        bw.write("回车="+entry.getValue());
                        break;
                    case '\n':
                        bw.write("换行="+entry.getValue());
                        break;
                    default:
                        bw.write(entry.getKey()+"="+entry.getValue());
                }
                bw.newLine();
            }

        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //关闭流
            if(bw!=null){
                try {
                    bw.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(br!=null){
                try {
                    br.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
结果：
空格=1
d=1
e=1
h=1
您=1
换行=2
l=3
,=1
界=1
回车=2
o=2
r=1
世=1
w=1
好=1
~~~

**注意：**

- 进行转入到map中的时候，如果数据不存在，新增的时候，需要赋初始值；若数据存在，值就加一
- 读入的时候需要转换数据格式为char
- 不要忘记关闭流

### 18.5 转换流（处理流之一或者叫做管道流之一）

- 转换流提供了在字节流和字符流之间的转换
- Java API提供了两个转换流：**属于字符流**
  - InputStreamReader：将InputStream（字节的输入流）转换为Reader（字符的输入流）
  - OutputStreamWriter：将Writer（字符的输出流）转换为OutputStream（字节的输出流）。符的输出需要通过字符流来操作，但是本质最后还是通过字节流输出到计算机上进行存储的
- 字节流的数据都是字符时，转成字符流操作更高效
- 很多时候使用转换流来处理文件乱码问题。实现编码和解码的功能
- 解码：字节、字节数组   ----->字符数组、字符串
- 编码：字符数组、字符串 ----->字节、字节数组

**InputStream案例（解码操作）**

~~~java
@Test
    public void inputStreamReaderTest(){
        InputStreamReader isr = null;
        InputStreamReader isr1 = null;
        try {
            FileInputStream fis = new FileInputStream("hello.txt");
//            //使用系统默认的字符集
//            isr = new InputStreamReader(fis);
            //指明了字符集，具体使用哪个字符集，取决于文件hello.txt保存时使用的字符集
            isr1 = new InputStreamReader(fis, "GBK");
            //读写
            char[] cbuf = new char[20];
            int len;
            while ((len = isr1.read(cbuf))!=-1){
                String s = new String(cbuf, 0, len);
                System.out.println(s);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //关闭流
            if(isr1!=null){
                try {
                    isr1.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
结果：
hello world
鎮ㄥソ,涓栫晫
~~~

**注意：**

- 使用第一种方式输出的数据，使用系统默认的字符集
- 指明了字符集，具体使用哪个字符集，取决于文件hello.txt保存时使用的字符集，这里指明为GBK，导致出现乱码的原因，主要是字符集不匹配
- 使用InputStreamReader的时候只有将字节流数据转换为字符流数据，所以这里使用String对象去接收数据进行输出
- 使用转换流也可以处理文件的乱码问题

**OutputStreamWriter案例**

~~~java
@Test
    public void test(){
        InputStreamReader isr = null;
        OutputStreamWriter osw = null;
        try {
            //1.实例化File
            File file1 = new File("hello.txt");
            File file2 = new File("hello_gbk.txt");
            //2.实例化字节流
            FileInputStream fis = new FileInputStream(file1);
            FileOutputStream fos = new FileOutputStream(file2);
            //3.实例化转换流(InputStreamReader,OutputStreamWriter)
            isr = new InputStreamReader(fis,"utf-8");
            osw = new OutputStreamWriter(fos,"GBK");
            //4.读写
            char[] cbuf = new char[10];
            int len;
            while ((len=isr.read(cbuf))!=-1){
                osw.write(cbuf,0,len);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //5.关闭流
            if(osw!=null){
                try {
                    osw.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(isr!=null){
                try {
                    isr.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
~~~

**注意：**

- 使用InputStreamReader和OutputStreamWriter的对象时候，可以添加编码格式，也可以选择默认
- 仍然使用write()方法写出数据
- InputStreamReader          字节流数据------>字符流数据
- OutputStreamWriter        字符流数据------->字节流数据
- 不要忘记关闭流

### 18.6 字符编码

- **编码表的由来：**计算机只能识别二进制数据，早期由来是电信号。为了方便应用计算机，让他可以识别各个国家的文字。就将各个国家的文字用数字来表示，并且一一对应，形成一张表，这就是编码表。
- **常见的编码表：**
  - ASCII：美国标准信息交换码
    - 用一个字节的7位可以表示
  - ISO8859-1：拉丁码表。欧洲码表
    - 用一个字节的8位表示
  - GB2313：中国的中文编码表。最多两个字节编码所有字符
  - GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码
  - Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示
  - UTF-8：变长的编码方式，可用1-4个字节来表示一个字符

**UTF-8或者UTF-16解析**

- 面向传输的众多UTF(UCS Transfer Format)标准出现了，顾名思义，UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。这是为传输而设计的编码。并使编码无国界，这样就可以显示全世界上所有文化的字符了。

- Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯一缺点的编号，具体存储成什么样的字节流，取决于字符编码方案。推荐Unicode编码是UTF-8和UTF-16

  Unicode符号范围|UTF-8编码方式

  （十六进制）          （二进制）

  0000 0000-0000 007F | 0xxxxxxx （兼容原来的ASCII码）

  0000 0080-0000 07FF | 110xxxxx 10xxxxxx （2个byte(字节)作为一个字符，看第一个1的个数决定byte个数）

  0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx（3个byte作为一个字符）

  0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx（4个byte作为一个字符）

- 一个中文在UTF-8中是3个字节

- 在标准的UTF-8编码中，超出基本语言范围的字符被编码为4字节格式，但是在修正的UTF-8编码中，他们由代理编码对表示，然后这些代码编码对在序列中分别重新编码。结果标准UTF-8编码中需要4个字节的字符。在修正的UTF-8中需要6个字节的字符。

- ANSI(美国国家标准协会)编码，通常指的是平台的默认编码。例如英文的操作系统中是ISO-8859-1，中文的是GBK

- Unicode字符集只是定义了字符的集合和唯一编号，Unicode编码，则是对UTF-8、UCS-2/UTF-16等具体编码方案的统称而已，并不是具体的编码方案

### 18.7 标准输入、输出流

- System.in 和System.out分别代表系统标准的输入和输出设备
- 默认输入设备是：键盘，输出设备是：显示器
- System.in的类型是InputStream：标准的输入流，默认从键盘输入
- System.out的类型是PrintStream，它是FileOutputStream的子类：标准的输出流、默认从控制台输出
- 重定向：通过System类的setIn，setOut方法对默认设备进行改变：重新指定输入和输出的流
  - public static void setIn(InputStream in)
  - public static void setOut(PrintStream out)

**其他流的使用：**

1. 标准的输入、输出流
2. 打印流
3. 数据流

**练习：从键盘输入字符串，要求读的字符串转成大写输出。然后继续输入操作，直至当输入“e”或者"exit"时，退出程序**

~~~java
/**
 * @author
 */
public class Test {


    public static void main(String[] args) {
//        Scanner scanner = new Scanner(System.in);
//        while (scanner.hasNext()){
//            System.out.println("请输入字符串：");
//            if(scanner.next().equalsIgnoreCase("e")||scanner.next().equalsIgnoreCase("exit")){
//                System.out.println("执行完毕");
//                break;
//            }
//            System.out.println("输出的结果："+scanner.next().toUpperCase());
//        }
        BufferedReader br = null;
        try {
            //创建流
            InputStreamReader isr = new InputStreamReader(System.in);
            //读取流
            br = new BufferedReader(isr);
            while (true){
                //读取并且打印
                System.out.println("请输入字符串：");
                String data = br.readLine();
                if("e".equalsIgnoreCase(data)||"exit".equalsIgnoreCase(data)){
                    System.out.println("程序结束");
                    break;
                }
                System.out.println(data.toUpperCase());
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //关闭流
            if(br!=null){
                try {
                    br.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
结果：
请输入字符串：
1e
1E
请输入字符串：
s
S
请输入字符串：
e
程序结束
~~~

**注意：**

- 可以使用Scanner和InputStreamReader两种方式输出数据，这里使用的是第二种方式
- equalsIgnoreCase(字符)忽略大小写
- 转换流(获取输入数据)    ---> 缓冲流（加快读写速度） -----> 读(readLine（读一行数据）)    -----> 输出数据    ------> 关闭流
- 不要忘记关闭流

**打印流**

- 实现将基本数据类型的数据格式转化为字符串输出
- 打印流：PrintStream和PrintWriter
  - 提供了一系列重载print()和printIn()方法，用于多种数据类型的输出
  - PrintStream和PrintWriter的输出不会抛出IOException
  - PrintStream和PrintWriter有自动flush功能
  - PrintStream打印的所有字符都使用平台默认字符编码转换字节。在需要写入字符而不是写入字节的情况下，应该使用PrintWriter类。
  - System.out返回的是PrintStream的实例

**打印流的案例**

~~~java
/**
 * @author
 */
public class PrintReaderTest {

    @Test
    public void test() {
        PrintStream ps = null;
        try {
            //节点流
            FileOutputStream fos = new FileOutputStream(new File("test.txt"));
            //创建打印输出流，设置自动刷新模式(写入换行符或字节'\n'时会刷新输出缓冲区)
            ps = new PrintStream(fos, true);
            if (ps != null) {
                //把标准输出流（控制台输出）改成文件
                System.setOut(ps);
            }
            //输出ASCll码
            for (int i = 0; i <= 255; i++) {
                System.out.print((char) i);
                if (i % 50 == 0) {
                    System.out.println();
                }
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } finally {
            //关闭流
            if (ps != null) {
                ps.close();
            }
        }
    }
}
~~~

**注意：**

- setOut(打印流对象)方法是将控制台输出的文件转换为文件进行存储
- new PrintStream(fos, true);参数true的意思就是使用了flush方法自动刷新缓冲流
- 不要忘记关闭流

**数据流（了解）**

- 为了方便操作Java语言的基本数据类型和String类型的数据，已使用数据流
- 数据流有两个类：（用于读取和写出基本数据类型、String类型的数据）
  - DataInputStream 和 DataOutputStream
  - 分别“套接”在InputStream和OutputStream子类的流上
- DataInputStream中的方法
  - boolean readBoolean()                 byte  readByte()
  - char readChar()                              float readFloat()
  - double readDouble()                     short  readFloat()
  - long readLong()                              int readInt()
  - String readUTF()                             void readFully(byte[] b)
- DataOutputStream中的方法
  - 将上述方法中的read改为write即可

**数据流的案例**

~~~java
/**
 * @author
 * 数据流
 */
public class DataStreamTest {
    /**
     * 数据输出流
     */
    @Test
    public void DataOutputStreamTest(){
        DataOutputStream dis = null;
        try {
            //创建数据读入流
            dis = new DataOutputStream(new FileOutputStream("data.txt"));
            //读入功能
            dis.writeUTF("zz");
            //刷新操作，将内存中的数据写入文件
            dis.flush();
            dis.writeInt(111);
            dis.flush();
            dis.writeBoolean(true);
            dis.flush();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if(dis!=null){
                try {
                    dis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    
    /**
     * 数据输入流
     * 将文件存储的基本数据类型和字符串读取到内存中，保存在变量中
     * 注意点：读取不同的类型的数据的顺序要与导出写入的顺序保持一致
     */
    @Test
   public void DataInputStreamTest(){
        DataInputStream dis = null;
        try {
            dis = new DataInputStream(new FileInputStream("data.txt"));
            //读入功能
            dis.readUTF();
            dis.readInt();
            dis.readBoolean();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if(dis!=null){
                try {
                    dis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
~~~

**注意：**

- 写出数据到内存文件中，读取的时候也需要根据写出的数据类型的顺序来进行读写
- dis.flush刷新操作，相当于写出数据之后，刷新一下流的通道
- 记住不要忘记输出和输入的含义（输出的意思就是从程序中输出到内存文件中，输入的意思就是从内存文件读取数据到程序中）
- 数据流主要用来将输入流放在对象的变量中
- 不要忘记关闭流

**对象流**

- ObejctInputStream和ObejctOutputStream
- 用于存储和读取基本数据类型数据或者对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把数据源中还原回来
- **序列化：**用ObjectOutputStream类**保存**基本类型数据或对象的机制(内存中保存到数据源中代表序列化)
- **反序列化：**用ObjectinputStream类**读取**基本类型数据或对象的机制（从数据源又回到内存中保存就叫做反序列化）
- ObjectOutputStream和ObejctInputStream不能序列化static和transiet修饰的成员变量 

**对象的序列化机制**

- **对象序列化机制：**允许把内存中的Java对象转化成平台无关的二进制流，从而允许把这种二进制流持久保存到硬盘上，或者通过网络将这种二进制流传输到另一个网络节点(序列化)。当其它程序获取了这种二进制流，就可以恢复成原来的Java对象（反序列化）
- 序列化的好处在于将任何实现了Serializable接口的对象转化为字节数据，使其在保存和传输时可被还原
- 序列化是RMI（Remote Method Invoke -远程方法调用）过程的参数和返回值都是必须实现的机制，而RMI是JavaEE的基础。因此序列化机制是JavaEE平台的基础
- 如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可以序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。否则会抛出异常（NotSerializableException）：
  - **Serializable**
  - **Externalizable**

**对象流案例**

~~~java
/**
 * @author
 * 测试对象流
 */
public class ObjectStreamTest {


    /**
     * 测试对象输出流
     * 序列化：将Java中的对象转换为磁盘文件中的对象
     */
    @Test
    public void objectOutputStreamTest(){
        ObjectOutputStream oos = null;
        try {
            //创建对象输出流和文件输出流(节点流)对象
            oos = new ObjectOutputStream(new FileOutputStream("object.data"));
            //写出数据
            oos.writeObject("我喜欢学习Java！");
            //刷新操作
            oos.flush();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //关闭流
            if(oos!=null){
                try {
                    oos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    /**
     * 测试对象输入流
     * 反序列化：将磁盘文件中的对象，还原为一个Java对象
     */
    @Test
    public void objectInputStreamTest(){
        ObjectInputStream ois = null;
        try {
            //实例化对象流，包括节点流
            ois = new ObjectInputStream(new FileInputStream("object.data"));
            //读入数据过程
            Object o = ois.readObject();
            String s  = (String) o;
            System.out.println(s);
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } finally {
            //关闭流
            if (ois != null) {
                try {
                    ois.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
结果：
我喜欢学习Java！
~~~

**注意：**

- 实例化对象流的时候需要实例化节点流
- 测试读入的时候需要确定文件存在，不存在会报异常
- 写出相当于是序列化，写入相当于是反序列化
- 不要忘记关闭流

### 18.8 总结

- IO流的分类方式：
  - 按照流的单位：字节流（8位(byte)）、字符流(16位(byte))
  - 按照流的流向：输入流、输出流
  - 按照流的角色：节点流、处理流
- 写出4个IO流的抽象基类，4个文件流、4个缓冲流：
  - 抽象基类：InputStream、OutputStream、Reader、Writer
  - 文件流：FileInputStream、FileOutputStream、FileReader、FileWriter
  - 缓冲流：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter
- 字节流与字符流的区别与使用情景：
  - 字节流：FileInputStream、FileOutputStream：主要用来处理非文本文件（内涵的一个就是处理不需要进行内容查看的文件，不管是非文本还是文本文件）。 read(cbuf);/ byte[] cbuf = new byte[读取的数据长度];
  - 字符流：FileReader、FileWriter：主要用来处理文本文件（不能用来处理非文本文件）read(buffer);/char[] buffer = new char[数据读取的长度];
- 转换类是哪两个类？分别的作用是什么？请分别创建两个类的对象：
  - InputStreamReader：将输入的字节流转换为输入的字符流。解码
  - OutputStreamWriter：将输出的字符流转换为输出的字节流。编码
  - InputStreamReader isr = new InputStreamReader(new FileInputStream("xxx.txt"),"UTF-8")；里面的两个参数分别是**文本文件**和**编码格式**，此时编码格式需要和文本文件的编码格式进行参照
  - OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStreamWriter("xxxxxxx.txt"),"GBK");里面的两个参数分别是**文本文件**和**编码格式**，此时的文本文件在内存中是不存在的，编码格式不需要参照，可以自己定义。
  - 提供字节流到字符流之间的转换
  - 编码决定解码（编码的字符集和解码的字符集如果不同，可能出现乱码）
- 相对路径在IDEA和Eclipse中使用的区别：
  - IDEA：
    - 如果使用单元测试方法（@Test），相对路径是基于当前Module的
    - 如果使用main()测试，相对路径是基于当前Project的
  - Eclipse：
    - 单元测试（@Test）和main()方法，相对路径都是基于当前project的
- 缓冲流的作用：
  - 提供流的读取、写入的速度
  - 提高读写速度的原因：内部提供一个缓冲区。默认情况下是8kb
  - 如果使用的是String类的readLine()方法，需要自己手动换行操作（xxx.newLine()方法）
  - 写出到内存的时候，需要使用flush进行刷新写出操作
- 对后面的启示：
  - 客户端/浏览器   <---->  后台（Java，GO，Python，Node.js，php）   <---->数据库
  - 要求这个之间使用的字符集要统一：UTF-8

## 19.注解与反射

### 19.1 Java反射机制概述

- Reflection(反射)被视为**动态语言**的关键，反射机制允许程序在执行期间借助反射(Reflection API)取得任何类的内部信息，并能直接操作任意对象的内部属性和方法。
- 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象(一个类只有一个Class对象)，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，通过镜子看到类的结构，所以，我们又形象地称之为：反射
- **正常方式： **引用需要的**包类**名称   ----->通过new实例化    ----->取得实例化对象
- **反射方式：**实例化Class对象   ----->getClass()方法    ------>得到完整**包类**的名称
- **动态语言**：是一类在运行时可以改变其结构的语言：例如：新的函数、对象、甚至是代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点就是**在运行时代码可以根据某些条件改变自身结构**：主要动态语言：Obejct-C、C#、JavaScript、PHP、Python、Erlang
- **静态语言：**与动态语言相对应的，运行时结构不可变的语言就是静态语言。如：Java、C、C++
- Java不是动态语言，但是Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制、字节码操作获得类似动态语言的特征。Java的动态性让编程的时候更加灵活。

**Java反射机制研究以及应用**

- 在运行时判断任意一个对象所属的类
- 在运行时构造任意一个类的对象
- 在运行时判断任意一个类所具有的的成员变量和方法
- 在运行时获取泛型信息
- 在运行时调用任意一个对象的成员变量和方法
- 在运行时处理注解
- 生成动态代理

**反射相关的主要API**

- java.lang.Class:代表一个类（此时这里的Class代表的是，这个类是通用的一个类，表示可以用很多类）
- java.lang.reflect.Method:代表类的方法
- java.lang.reflect.Field:代表类的成员变量
- java.lang.reflect.Constructor:代表类的构造器
- ...

### 19.2 理解Class类并获取Class实例

**正常与反射的对比测试**

~~~java
/**
 * @author
 * 正常与反射的对比测试
 */
public class ReflectionTest {

    @Test
    public void test01(){
        Person person = new Person();
        person.age=10;
        System.out.println(person.age);
        person.show();
    }

    @Test
    public void test02() throws Exception{
        //通过反射获取类
        Class clazz = Person.class;
        //通过反射设置构造器：
        Constructor cons = clazz.getConstructor(String.class, int.class);
        //通过反射创建对象
        Object obj = cons.newInstance("Tom", 12);
        Person p = (Person) obj;
        System.out.println(obj);
        //通过反射获取属性和方法
        Field age = clazz.getDeclaredField("age");
        age.set(p,10);
        System.out.println(p);

        //通过反射调用方法
        Method show = clazz.getDeclaredMethod("show");
        show.invoke(p);

        //通过反射调用私有构造器(有参构造器)
        Constructor cons1 = clazz.getDeclaredConstructor(String.class);
        //Accessible属性是继承自AccessibleObject 类. 功能是启用或禁用安全检查
        cons1.setAccessible(true);

        //通过反射创建私有对象
        Object o = cons1.newInstance("Jerry");
        Person p1 = (Person) o;
        System.out.println(p1);

        //通过反射调用私有的属性，并且设置值
        Field name = clazz.getDeclaredField("name");
        //Accessible属性是继承自AccessibleObject 类. 功能是启用或禁用安全检查
        name.setAccessible(true);
        name.set(p1,"Jack");
        System.out.println(name);
        
        //通过反射调用私有方法
        Method showNation = clazz.getDeclaredMethod("showNation", String.class);
        //Accessible属性是继承自AccessibleObject 类. 功能是启用或禁用安全检查
        showNation.setAccessible(true);
        showNation.invoke(p1,"中国");

    }
结果：
Person{name='Tom', age=12}
Person{name='Tom', age=10}
人
Person{name='Jerry', age=0}
private java.lang.String Person.name
国籍是：中国
~~~

**注意：**

- 正常方式创建类的对象：Person person = new Person();        反射获取类的对象： Object obj = cons.newInstance("Tom", 12);
- 正常方式对象赋值：person.age=10;                                           反射方式对象赋值：Field age = clazz.getDeclaredField("age");   age.set(p,10);
- 正常方式调用方法：person.show();                                            反射方式调用方法：Method show = clazz.getDeclaredMethod("show");    show.invoke(p);
- 反射方式调用私有构造器：Constructor cons1 = clazz.getDeclaredConstructor(String.class);     cons1.setAccessible(true);
- 反射方式调用私有构造器创建私有对象： Object o = cons1.newInstance("Jerry");   Person p1 = (Person) o;
- 反射方式调用私有方法：Method showNation = clazz.getDeclaredMethod("showNation", String.class);   showNation.setAccessible(true);  showNation.invoke(p1,"中国");
- setAccessible是启用或禁用访问安全检查的开关,并不是为true就能访问为false就不能访问

**疑问：**

- **通过直接new的方式或反射的方式都可以调用公共的结构，开发中到底用哪个？**
  - 建议：直接new的方式，首先new的方式可以直接确定是哪一个类的对象，但是反射不一样，反射的时候可以不用确定是哪一个类的对象。举个例子：登录和注册的时候会经过服务器，因为服务要先开启，在最开始的时候使用反射进行数据的造对象（这个对象的类型不明确），只要登录和注册传递过来之后，就确定类型并且创建对象。这里体现了反射的用处。还体现了动态性。
  - 反射的特征就是：动态性（Java是准动态语言在这里体现出来，但是Java仍然是静态语言）。
- **反射机制与面向对象的封装性是不是相互矛盾？如何看待这两个技术？**
  - 封装性的体现例子：一个类中有既有私有方法也有公共的方法，他们需要私有的意思就有：不能直接调用私有方法或者属性，必须通过其他的方式来调用
  - 反射机制：这里就是说，类中既有私有也有公共的属性和方法，需要进行判断时候即使你有其他的方式调用私有的属性或者方法，你也可以调用私有的方法或者属性，即使公共方法可以更加方便调用私有方法的时候，也可以使用私有的属性（比较有特权）。
  - 反射机制主要是为了保证能不能调用（可不可以），封装性表示的是该怎么调用（怎么用）。

**关于java.long.Class类的理解：**

1. 类的加载过程：
   1. 编译过程：程序经过java.exe命令以后，会生成一个或多个字节码文件（.class结尾）。
   2. 解释运行：接着我们使用java.exe命令对某个字节码文件进行解释运行，相当于将某个字节码文件（在IDAE中的out文件夹下面就有字节码文件，java.exe就是通过拿到这个字节码文件之后进行运行的）加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称之为**运行时类**，此运行时类，就作为Class类的一个实例。（类本身也是Class的对象）；
2. 换句话说，Class的实例就是对应着一个运行时类，意思就是不能直接new一个Class这个类的对象，需要直接赋值（值一般就是一个类）等于这个类的对象。Class clazz = Person.class；
3. 加载到内存中的运行时类，会缓存一段时间。在此时间之内，我们可以通过不同的方式来获取此运行时类。在生命周期创建了这个类之后，如果其他的想用这个类，就不会去创建新的类，全都是指向这个类。

**获取Class的实例案例**

~~~java
	/**
     * 获取Class的实例的方式
     */
    @Test
    public void test03() throws ClassNotFoundException {
        //方式一：调用运行时类的属性：.class
        Class<Person> clazz1 = Person.class;
        System.out.println(clazz1);

        //方式二：运行时类的对象，调用getClass()
        Person person = new Person();
        Class clazz2 = person.getClass();
        System.out.println(clazz2);

        //方式三：调用Class的静态方法：forName(String,classPath)
        Class clazz3 = Class.forName("Person");
        System.out.println(clazz3);

        //方式四：使用类的加载器获取Class实例： ClassLoader，此时这里是自定义类加载器
        ClassLoader classLoader = ReflectionTest.class.getClassLoader();
        Class<?> clazz4 = classLoader.loadClass("Person");
        System.out.println(clazz4);

        System.out.println(clazz1 == clazz2);
        System.out.println(clazz1 == clazz3);
        System.out.println(clazz1 == clazz4);
    }
结果：
class Person
class Person
class Person
class Person
true
true
true
~~~

**注意：**

- 前三种必须掌握
- 第三种方式使用频率最高，主要是因为第三种更能体现反射（方法的参数可以随意输入字符，不会在编译的时候就找不到这个类，也可以验证那句话：**“代码运行的时候可以根据某些条件改变类的结构”**）
- 类也可以被称为对象

**哪些类型可以有Class对象**

- class：外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类
- interface：接口
- []：数组
- enum：枚举
- anotation：注解@interface
- primitive type：基本数据类型
- void

**Class实例可以是哪些结构案例**

~~~java
@Test
    public void test04(){
        //Obejct类
        Class c1 = Object.class;
        //接口类
        Class c2 = Comparable.class;
        //字符串数组类
        Class c3 = String[].class;
        //二维数组类
        Class c4 = int[][].class;
        //元素类
        Class c5 = ElementType.class;
        //注解类
        Class c6 = Override.class;
        //基本数据类
        Class c7 = int.class;
        //void
        Class c8 = void.class;
        //Class类
        Class c9 = Class.class;
    
        //判断数组是否为同一个Class
        int[] a = new int[10];
        int[] b = new int[100];
        Class c10 = a.getClass();
        Class c11 = b.getClass();
        //只要元素类型与维度一样，就是同一个Class
        System.out.println(c10==c11);
    }
结果：
true
~~~

**注意：**

- 数据类型和维度相同，那么他们指向的是同一个类

### 19.3 类的加载与ClassLoader的理解

当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化。

- 类的加载（Load）：将类的Class文件(字节码文件)读入内存，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的Java.lang.Class对象，作为方法区中类数据的访问入口（及引用地址）。所有需要访问和使用类数据只能通过这个Class对象。这个加载过程需要类加载器(ClassLoader)参与。
- 类的链接（Link）：将类的二进制代码合并到JVM的运行状态之中的过程：
  - 验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全的问题
  - 准备：正式为类变量（static）分配内存并**设置类变量默认初始值**的阶段(比如说在static int n的时候，在链接的时候就会把n设置一个默认值0)，这些内存都在方法区中进行分配
  - 解析：虚拟区常量池内的符号引用（常量名）替换为直接引用（地址）的过程
- 类的初始化（initialize）：JVM负责对类进行初始化
  - 执行**类构造器<clinit>（）方法**的过程。类构造器<Clinit>()方法是由编译期自动搜集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（**类构造器是构造类信息的，不是构造该类对象的构造器**）。作用就是将**显式**的属性值进行触发比如说那些修饰符是public的数据。
  - 当初始化一个类的时候，如果发现其父类没有进行初始化，则需要先触发其父类的初始化。
  - 虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。
- 加载顺序：源程序（ *.java） -------->（通过java编译器）字节码（ *.class）--------->类加载器 ------->字节码校验器 ------>解释器 ------>操作系统平台

**类加载器的作用：**

- **类加载的作用：**将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后再堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。
- **类缓存：**标准的javaSE类加载器可以按照要求查找类，一旦某个类被加载到类加载器中，他将维持加载（缓存）一段时间。不过jvm垃圾回收机制可以回收这些class对象。

**类的加载案例**

~~~java
/**
 * @author
 * 测试类的加载过程
 */
public class ClassLoaderTest {

    public static void main(String[] args){
        System.out.println(A.m);
    }
}

class A{
    static {
        m = 300;
    }
    static int m = 100;
}
结果：
100
~~~

**注意**

- 第一步：类的加载，java.exe会去加载Class文件（该文件在输出文件夹下面）读入到内存中，然后生成一个java.lang.Class的对象。所有需要访问该类都是访问的这个对象

- 第二步：类的链接：这一步就是将里面的静态变量或者是显式的变量赋值为默认值，此时这里是int类型的数据，所以默认值为0

- 第三步初始化：m的值由<clinit>()方法由类变量的赋值和静态代码块中的语句按照顺序合并产生。类似于

  - <clinit>(){

       m = 300;

       m = 100;

  - }

- 最终输出的值就是100；

**了解：ClassLoader**

类加载器作用是用来把类（class）装载进内存的。JVM规范定义了如下类型的类加载器：

- Bootstrap ClassLoader：引导类加载器：用C++编写的，是jvm自带的类加载器，负责java平台核心库，用来装载核心类。该加载器无法直接获取
- Extension ClassLoader：扩展类加载器：负责jre/lib/ext目录下的jar包（就是加载的jdk安装目录下的jre/lib/ext里面的包）或 -D java.ext.dirs 指定目录下的jar包装入工作库
- System ClassLoader：负责java -classpath 或 -D java.class.path所指的目录下的类与jar包装入工作，是最常用的加载器
- 自定义类加载器
- 倒叙表示类是否已经装载；正序表示尝试加载类

**测试类加载器案例**

~~~java
/**
 * @author
 */
public class ClassLoaderTest {

    @Test
    public void test01(){
        //对于自定义类，使用系统类加载器进行加载
        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
        System.out.println(classLoader);

        //调用系统类加载器的getParent():获取扩展类加载器
        ClassLoader classLoader1 = classLoader.getParent();
        System.out.println(classLoader1);

        //调用扩展类加载器的getParent():无法获取引导类加载器
        //引导类加载器主要负责加载java的核心类库，无法加载自定义类的
        ClassLoader classLoader2 = classLoader1.getParent();
        System.out.println(classLoader2);

        //此时发现String也属于引导类
        ClassLoader classLoader3 = String.class.getClassLoader();
        System.out.println(classLoader3);
    }
}
结果：
sun.misc.Launcher$AppClassLoader@18b4aac2
sun.misc.Launcher$ExtClassLoader@8efb846
null
null
~~~

**注意：**

- 因为引导类加载器用来装载核心类库，是不可以直接获取的，所以这里为null
- 这个也可以用来判断该类是否为引导类

**测试配置文件**

~~~java
@Test
    public void test02() throws Exception {

        Properties pros = new Properties();
        //此时的文件默认在当前module下面
        //读取配置文件的方式一：
//        FileInputStream fis = new FileInputStream("jdbc.properties");
//        FileInputStream fis = new FileInputStream("src\\jdbc1.properties");
//        pros.load(fis);

        //读取配置文件的方式二：使用ClassLoader
        //配置文件默认识别为：当前module的src下
        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
        InputStream is = classLoader.getResourceAsStream("jdbc1.properties");
        pros.load(is);

        String user = pros.getProperty("user");
        String password = pros.getProperty("password");
        System.out.println("用户名："+ user +"密码："+password);
    }
结果：
用户名："张三"密码："123456"
~~~

**注意：**

- 使用流方式进行数据读取的时候，选择文件的是当前module下面的配置文件
- 使用类加载器读取数据的时候，选择文件的是当前module的src下面的配置文件
- 一般把配置文件都是放在**module的src下面**，如果是将配置文件放在module或者工程的目录下面，配置到服务器上面的时候就会丢失。

### 19.4 创建运行时类的对象

~~~java
/**
 * @author
 */
public class Person {

    private String name;
    public int age;

    public Person() {
        System.out.println("Person()");
    }

    private Person(String name) {
        this.name = name;
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void show(){
        System.out.println("人");
    }

    private String showNation(String nation){
        System.out.println("国籍是："+nation);
        return nation;
    }
    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
------------------
@Test
    public void test05() throws Exception {
        Class<Person> clazz = Person.class;
        /**
         * newInstance():调用此方法，创建对应的运行时类的对象,内部调用了运行时类的空参构造器
         */
        Constructor cons = clazz.getDeclaredConstructor();
        Person o = clazz.newInstance();
        System.out.println(o);
    }
结果：
Person()
Person{name='null', age=0}
~~~

**注意：**

- 通过调用newInstance()方法，想要他正常运行：
  - 运行时类必须提供空参构造器
  - 空参的构造器的访问权限必须满足。通常：设置为public
- 在javabean中要求提供一个public的空参构造器。原因：
  - 便于通过反射，创建运行时类的对象
  - 便于子类继承此运行时类，默认调用super()时，保证父类此构造器

~~~java
//反射的动态性
    @Test
    public void test06() {

        for (int i = 0; i < 100; i++) {
            int num = new Random().nextInt(3);
            String classPath = "";
            switch (num) {
                case 0:
                    classPath = "java.util.Date";
                    break;
                case 1:
                    classPath = "java.lang.Object";
                    break;
                case 2:
                    classPath = "Person";
                    break;
            }
            Object o = null;
            try {
                o = getInstance(classPath);
                System.out.println(o);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

    }
	//获取Class实例
    public Object getInstance(String classPath) throws Exception {
        Class clazz = Class.forName(classPath);
        return clazz.newInstance();
    }
结果：
....
Person{name='null', age=0}
Person()
Person{name='null', age=0}
Fri Jun 18 15:27:55 CST 2021
Fri Jun 18 15:27:55 CST 2021
Fri Jun 18 15:27:55 CST 2021
Person()
Person{name='null', age=0}
Person()
Person{name='null', age=0}
Fri Jun 18 15:27:55 CST 2021
Person()
Person{name='null', age=0}
java.lang.Object@2957fcb0
Fri Jun 18 15:27:55 CST 2021
Person()
Person{name='null', age=0}
java.lang.Object@1376c05c
java.lang.Object@51521cc1
java.lang.Object@1b4fb997
java.lang.Object@deb6432
Person()
......
~~~

- 通过设置随机数，来判断是否执行哪一个，这就解释了反射机制，最开始的时候就是实例化Class，此时并不知道数据类型，到后面才会根据随机数更改数据结构。这也验证了反射的机制和java被称为准动态语言。

### 19.5 获取运行时类的完整结构

**获取属性案例**

~~~java
/**
 * @author
 */
public class FileTest {

    @Test
    public void test01() throws ClassNotFoundException {
        Class clazz = Person.class;
        //获取属性结构
        //getFields()：获取当前运行时类及其父类中声明为public访问权限的属性
        Field[] f = clazz.getFields();
        for (Field ff : f) {
            System.out.println(ff);
        }
        System.out.println("--------------");

        //getDeclaredFields():获取当前运行时类的所有属性(不包含父类声明的属性)
        Field[] f1 = clazz.getDeclaredFields();
        for (Field ff1 : f1) {
            System.out.println(ff1);
        }
        System.out.println("================");
    }

    //权限修饰符 数据类型 变量名
    @Test
    public void test02(){
        Class clazz = Person.class;
        Field[] fields = clazz.getDeclaredFields();
        for (Field field : fields) {
            //1.权限修饰符
            int modifiers = field.getModifiers();
            System.out.print(Modifier.toString(modifiers) + "\t");

            //2.数据类型
            Class type = field.getType();
            System.out.print(type +"\t");

            //3.变量名
            String name = field.getName();
            System.out.println(name);
        }
    }
}
结果：
public int java1.Person.id
public double java1.Creature.weight
--------------
private java.lang.String java1.Person.name
int java1.Person.age
public int java1.Person.id
================
private	class java.lang.String	name
	int	age
public	int	id
~~~

**注意：**

- clazz.getFields();获取当前运行时类及其父类中声明为public访问权限的属性
- clazz.getDeclaredFields();获取当前运行时类的所有属性(不包含父类声明的属性)
- field.getModifiers();    Modifier.toString(modifiers)：通过Modifier的toString方法可以获取数据的修饰符，否则就是一个数字，这个数字代表的就是修饰符的编号。如果没有修饰符的时候，编号默认为0；输出的是一个空格

### 19.6 调用运行时类的指定结构

**获取运行时类的方法结构案例**

~~~java
/**
 * @author
 */
public class MethodsTest {

    @Test
    public void test01(){
        Class clazz = Person.class;
        //getMethods():获取此运行时类及其父类声明为public权限的方法
        Method[] methods = clazz.getMethods();
        for (Method method : methods) {
            System.out.println(method);
        }
        System.out.println("============================================================");
        //getDeclaredMethods():获取此运行时类的所有方法，不包括它的父类
        Method[] methods1 = clazz.getDeclaredMethods();
        for (Method method1: methods1){
            System.out.println(method1);
        }
    }
}
结果：
public int java1.Person.compareTo(java.lang.String)
public int java1.Person.compareTo(java.lang.Object)
public void java1.Person.info()
public java.lang.String java1.Person.display(java.lang.String)
public void java1.Creature.eat()
public final void java.lang.Object.wait() throws java.lang.InterruptedException
public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException
public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException
public boolean java.lang.Object.equals(java.lang.Object)
public java.lang.String java.lang.Object.toString()
public native int java.lang.Object.hashCode()
public final native java.lang.Class java.lang.Object.getClass()
public final native void java.lang.Object.notify()
public final native void java.lang.Object.notifyAll()
=====================================================
public int java1.Person.compareTo(java.lang.String)
public int java1.Person.compareTo(java.lang.Object)
public void java1.Person.info()
public java.lang.String java1.Person.display(java.lang.String)
private java.lang.String java1.Person.show(java.lang.String)
~~~

**注意：**

- clazz.getMethods()：获取此运行时类及其父类声明为public权限的方法
- clazz.getDeclaredMethods()：获取此运行时类的所有方法，不包括它的父类

**反射查看修饰符，返回值类型，方法名等**

~~~java
/**
     * 权限修饰符  返回值类型  方法名（形参1，形参2） throws XxxException{
     *
     * }
     */
    @Test
    public void test02(){
        //获取修饰符
        Class clazz = Person.class;
        Method[] methods = clazz.getDeclaredMethods();
        for (Method method : methods) {
            //获取方法声明的注解
            Annotation[] annotation = method.getAnnotations();
            for (Annotation annotation1 : annotation) {
                System.out.println(annotation1);
            }
            //获取权限修饰符
            System.out.print(Modifier.toString(method.getModifiers()) + "\t");
            //返回值类型
            System.out.print(method.getReturnType()+"\t");
            //获取方法名
            System.out.print(method.getName());
            System.out.print("(");
            //形参列表
            Class[] types = method.getParameterTypes();
            if(!(types == null && types.length==0)){
                for (int i = 0; i < types.length; i++) {
                    if(i == types.length-1){
                        System.out.print(types[i].getName()+" args_" + i);
                        break;
                    }
                    System.out.print(types[i].getName() + " args_" + i +",");
                }
                System.out.print(")");
            }
            //抛出异常
            Class[] exceptionTypes = method.getExceptionTypes();
            if(exceptionTypes.length>0){
                System.out.print(" throws ");
                for (int i = 0; i < exceptionTypes.length; i++) {
                    if(i == exceptionTypes.length-1){
                        System.out.print(exceptionTypes[i].getName());
                    }else{
                        System.out.print(exceptionTypes[i].getName() + ",");
                    }
                }
            }
            System.out.print(" {" +"} ");
            System.out.println();
        }
    }
结果：
public	int	compareTo(java.lang.String args_0) {} 
public volatile	int	compareTo(java.lang.Object args_0) {} 
public	void	info() {} 
public	class java.lang.String	display(java.lang.String args_0) throws java.lang.NullPointerException,java.lang.ClassNotFoundException {} 
@java1.MyAnnotation(value=hello)
private	class java.lang.String	show(java.lang.String args_0) {} 
~~~

**注意：**

- 通过反射查看方法的组成成分
- method.getAnnotations(); 获取方法的注解
- Modifier.toString(method.getModifiers())；获取方法的权限修饰符
- method.getReturnType()；获取方法的返回值类型
- method.getExceptionTypes()；获取方法的异常
- 获取这些数据都是数组形式，遍历的时候需要判断数据是否存在

**反射获取构造器**

~~~java
	/**
     * 通过反射获取构造器
     */
    @Test
    public void test03(){
        Class clazz = Person.class;
        //获取当前运行时类的所有声明为public的构造器
        Constructor[] cons = clazz.getConstructors();
        if(cons!=null && cons.length!=0){
            for (Constructor con : cons) {
                System.out.println(con);
            }
        }
        //获取当前运行时类的所有构造器
        Constructor[] constructors = clazz.getDeclaredConstructors();
        if(constructors.length>0){
            for (Constructor constructor : constructors) {
                System.out.println(constructor);
            }
        }
    }
结果：
public java1.Person()
java1.Person(java.lang.String,int)
private java1.Person(java.lang.String)
public java1.Person()
~~~

**注意：**

- clazz.getConstructors();获取当前运行时类的所有声明为public的构造器，这里要和获取方法那里区别，这里只能获取此运行时类的构造器，父类构造器获取不了（用super可以）
- clazz.getDeclaredConstructors();获取当前运行时类的所有构造器，包括私有的和默认的

**调用相关属性和方法**

~~~java
	/**
     * 如何操作运行时类中的指定的属性 -- 需要掌握
     */
    @Test
    public void test02() throws Exception {
        Class clazz = Person.class;
        //创建运行时类的对象
        Person p = (Person) clazz.newInstance();
        //获取指定变量名的属性
        Field name = clazz.getDeclaredField("name");
        //确保能够访问
        name.setAccessible(true);
        //设置值
        name.set(p,"张三");
        System.out.println(name.get(p));
    }
------------------
结果：
张三

	/**
     * 如何操作运行时类中的指定的方法 -- 需要掌握
     */
    @Test
    public void test03() throws Exception {
        Class clazz = Person.class;
        //创建运行时类的对象
        Person p = (Person) clazz.newInstance();
        //获取指定的某个方法：参数1：指明获取的方法名称；参数2：指明获取的参数列表
        Method method = clazz.getDeclaredMethod("show", String.class);
        //保证当前方法可以安全访问
        method.setAccessible(true);
        //使用方法 invoke():参数1：方法的调用者 参数二：给方法形参赋值的实参，如果没有就不填写
        //invoke()的返回值即为对应类中调用方法的返回值
        method.invoke(p,"中国");

        System.out.println("****************下面展示调用静态方法******************");

        Method say = clazz.getDeclaredMethod("say");
        say.setAccessible(true);
        //调用静态方法，参数为null也可以获取该类的静态方法，因为clazz已经知道调用的是Person这个类了
        Object invoke = say.invoke(Person.class);
        //Object invoke = say.invoke(null);
        System.out.println(invoke);
    }
结果：
我的国籍是：中国
****************下面展示调用静态方法******************
我是java工程师
null
----------------------
	/**
     * 通过反射获取构造器  -- 需要掌握
     * @throws Exception
     */
    @Test
    public void test04() throws Exception {
        Class clazz = Person.class;
        //获取指定的构造器
        Constructor cons = clazz.getDeclaredConstructor(String.class);
        //保证该构造器可以正常访问
        cons.setAccessible(true);
        //创建对象
        Person tom = (Person) cons.newInstance("Tom");
        System.out.println(tom);
    }
结果：
Tom
~~~

**注意：**

- 获取指定的属性和方法时候，如果该属性(方法)是私有的，就需要设置安全访问setAccessible(true);
- 调用静态方法或者静态属性的时候，需要将参数设置为该类的类名；
  - 设置静态属性set(类名.class，"属性值");
  - 设置静态方法invoke(类名.class或者是null);
- 获取构造器的时候，也是需要指定参数列表

**复习：**

- 写出获取Class实例的三种方式

  - 方式一：通过反射获取：Class clazz = 类名.class;
  - 方式二：通过new 对象获取: Person person = new Person; person.getClass();
  - 方式三：通过类名来获取： Class clazz = Class.forName("类名");
  - 方式四：通过类加载器来获取：ClassLoader loader =  类名.class.getClassLoader(); loader.loadClass("类名");

- 谈谈对Class类的理解

  - Class实例对应着加载到内存中的一个运行时类

- 创建Class类对应运行时类的对象的通用方法，代码实现。以及这样操作，需要对应的运行时类构造器方面满足的要求。

  - Object obj = clazz.getInstance();创建了对应的运行时类的对象
  - 1.必须要有一个空参的构造器
  - 2.权限修饰符的权限要够。通常设置为public
  - javabean中要求提供一个public的空参构造器。原因：
    - 便于通过反射，创建运行时类的对象
    - 便于子类继承此运行时类，默认调用super()时，保证父类此构造器

- 在工程或module的src下有名为：“jdbc.properties”的配置文件，文件内容为：name=Tom。如何在程序中通过代码获得Tom这个变量

  ~~~java
  @Test
      public void test05() throws Exception{
          //实例化Properties
          Properties properties = new Properties();
          //获取类加载器
          ClassLoader classLoader = MethodsTest.class.getClassLoader();
          //获取资源流，注意这里文件的地址应该是
          InputStream ras = classLoader.getResourceAsStream("src\\jdbc1.properties");
  
          properties.load(ras);
  
          String name = properties.getProperty("name");
          System.out.println(name);
      }
  结果：
  Tom
  ~~~

  **注意：**此时这里的文件地址应该是本module下面的，如果没有module就是本项目下面的

- 关于反射的理解：

  - Reflection(反射)是被视为动态语言的关键，反射机制允许程序再执行期借助Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法
  - 框架 = 反射 + 注解 + 设计模式

- 理解反射的“动态性”

  ~~~java
  //反射的动态性
      @Test
      public void test06() {
          for (int i = 0; i < 100; i++) {
              int num = new Random().nextInt(3);
              String classPath = "";
              switch (num) {
                  case 0:
                      classPath = "java.util.Date";
                      break;
                  case 1:
                      classPath = "java.lang.Object";
                      break;
                  case 2:
                      classPath = "Person";
                      break;
              }
              Object o = null;
              try {
                  o = getInstance(classPath);
                  System.out.println(o);
              } catch (Exception e) {
                  e.printStackTrace();
              }
          }
  
      }
  	//获取Class实例
      public Object getInstance(String classPath) throws Exception {
          Class clazz = Class.forName(classPath);
          return clazz.newInstance();
      }
  ~~~
  

**注意：**方法getInstance()：里面的参数就是不同的类名，根据不同的类名，就可以得到不同的Class实例

- 反射机制提供的功能

  - 在运行时判断**任意**一个对象所属的类
  - 在运行时构造**任意**一个类
  - 在运行时判断**任意**一个**类**所具有的成员变量和方法
  - 在运行时获取泛型信息
  - 在运行时调用**任意**一个**对象**的成员变量和方法
  - 在运行时处理注解
  - 生成动态代理

- 反射相关的API

  - java.lang.Class:反射的源头
  - java.lang.reflect.Method
  - java.lang.reflect.Field
  - java.lang.reflect.Constructor
  - ....

### 19.7 反射的应用：动态代理

- 代理模式的原理：
  - 使用代理将对象包装起来，然后用代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上
  - 静态代理的特征就是代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。同时，每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。**最好可以通过一个代理类完成全部的代理功能**
- 动态代理是指客户通过代理类来调用其他对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象
- 动态代理使用场合：
  - 调试
  - 远程方法调用
- 动态代理相比于静态代理的优点：
  - 抽象角色中（接口）声明的所有方法都被转移到调用处理器一个集合的方法中处理，这样，我们可以更加灵活和统一的处理众多的方法。

**静态代理模式案例**

~~~java
/**
 * 静态代理模式
 * @author
 */
public class StaticProxyTest {

    @Test
    public void test01(){
        //创建你对象
        You you = new You();
        //创建代理对象，调用代理对象的构造器，将你这个类的对象传递进去
        Web web = new Web(you);
        //调用代理购物的方法
        web.shopping();
    }
}
//购物接口类包括方法
interface Shop{
    void shopping();
}

class Web implements Shop{
    //封装一个被代理的属性
    private Shop shop;
    //带参构造器，用于传递被代理的对象
    public Web(Shop shop){
        this.shop = shop;
    }
    //购物方法
    @Override
    public void shopping() {
        System.out.println("代理网站进行购物");
        //被代理对象的购物方法
        shop.shopping();
        System.out.println("代理网站进行结账");
    }
}
/**
 * 被代理类实现接口
 */
class You implements Shop{
    @Override
    public void shopping() {
        System.out.println("自己购物");
    }
}
结果：
代理网站进行购物
选择购物
代理网站进行结账
~~~

**注意：**

- 静态代理在编译的时候就已经确定了是哪一个类需要代理
- 代理类里面封装一个接口类的方法（主要是为了被代理类可以进行操作）
- 被代理对象可以通过代理类的对象实现接口方法,从而实现代理

**动态代理模式案例**

**思路**

- 创建接口类(都要使用)
- 创建代理工厂类
- 创建自定义处理代理类去实现底层代理处理程序接口(MyInvocationHandler implements InvocationHandler)
- 重写invoke()方法，里面获取对象的所有方法和通用方法
- 添加构造对象方法
- 创建被代理类，实现接口类方法
- 编写main方法
- 创建被代理类
- 通过代理工厂类的创建代理方法，参数就是被代理类
- 调用被代理类的所有方法（这些方法都是实现被代理接口类的方法，自己的方法好像不可以调用，如果需要使用自己的方法，就可以自己进行反射获取并调用）

~~~java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * @author
 * 被代理接口类
 */
interface Human{
    String fly();
    void eat(String food);
}
/**
 * 要想实现动态代理，需要解决的问题
 * 问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象
 * 问题二：当通过代理类的对象调用方法时，如何动态的去调用被代理类中的同名方法
 *
 */
class ProxyFactory{
    /**
     * 调用此方法，返回一个代理类的对象。解决一：
     */
    public static Object getProxyInstance(Object obj){//obj:被代理的对象
        MyInvocationHandler handler = new MyInvocationHandler();
        handler.bind(obj);
        //obj.getClass().getClassLoader(): 用哪个类加载器去加载代理对象;
        //obj.getClass().getInterfaces():动态代理类需要实现的接口;
        //handler:动态代理方法在执行时，会调用handler里面的invoke方法去执行
        return Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler);
    }
}

/**
 * @author
 */
public class ProxyTest {

    public static void main(String[] args) {
        SuperMan superMan = new SuperMan();
        //proxyInstance:代理类对象
        Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan);
        //当通过代理类对象调用方法时，会自动调用被代理类中同名的方法
        String fly = proxyInstance.fly();
        System.out.println(fly);
        proxyInstance.eat(" 火锅");
        System.out.println("*************************************");
    }

}

/**
 * 1.InvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，
 * 每一个proxy代理实例都有一个关联的调用处理程序；在代理实例调用方法时，方法调用被编码分派到调用处理程序的invoke方法。
 * 2.Proxy类就是用来创建一个代理对象的类，它提供了很多方法，但是我们最常用的是newProxyInstance方法。
 * 
 */
class MyInvocationHandler implements InvocationHandler{
    /**
     * 需要使用被代理类的对象进行赋值
     */
    private Object obj;
    /**
     * 该方法只是一个赋值
     * @param obj
     */
    public void bind(Object obj){
        this.obj = obj;
    }
    /**
     * 当我们通过代理类的对象，调用方法a时，就会自动调用如下方法：invoke()
     * 当被代理类要执行的方法a的功能就声明在invoke（）中
     * @param proxy
     * @param method
     * @param args
     * @return
     * @throws Throwable
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法
        //obj：被代理类的对象,从中调用底层方法的对象，必须是实例化对象
        //args： 用于方法的调用，是一个object的数组，参数有可能是多个
        Object invoke = method.invoke(obj, args);
        //上述方法的返回值就是作为当前类中的invoke()的返回值
        return invoke;
    }
}
//被代理类
class SuperMan implements Human{
    @Override
    public String fly() {
        return "i believe i can fly";
    }
    @Override
    public void eat(String food) {
        System.out.println("i like eat"+ food);
    }
}
结果：
i believe i can fly
i like eat 火锅
*************************************
~~~

**注意：**

- 代理工厂会根据**不同的被代理类**创建代理类的对象，这里就体现了反射的动态性（根据不同的运行条件改变类的结构）
- 需要一个代理工厂（该工厂就是用来处理被代理类）
- 需要重写invoke方法，创建好了的代理工厂调用方法的时候，就是调用invoke()方法获取该对象的所有方法
- invoke里面的method.invoke(obj,args);这个方法的意思其实就是通过反射获取到原来的方法名，只是说method的这个名字改变了，变成了一个通用的名称(就相当于形参的性质)。

**动态代理和AOP普通案例**

~~~java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * @author 被代理接口类
 */
interface Human {
    String fly();

    void eat(String food);
}

/**
 * 要想实现动态代理，需要解决的问题
 * 问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象
 * 问题二：当通过代理类的对象调用方法时，如何动态的去调用被代理类中的同名方法
 */
class ProxyFactory {
    /**
     * 调用此方法，返回一个代理类的对象。解决一：
     */
    public static Object getProxyInstance(Object obj) {//obj:被代理的对象
        MyInvocationHandler handler = new MyInvocationHandler();
        handler.bind(obj);
        //obj.getClass().getClassLoader(): 用哪个类加载器去加载代理对象;
        //obj.getClass().getInterfaces():动态代理类需要实现的接口;
        //handler:动态代理方法在执行时，会调用handler里面的invoke方法去执行
        return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), handler);
    }
}

/**
 * @author
 */
public class ProxyTest {

    public static void main(String[] args) {
        SuperMan superMan = new SuperMan();
        //proxyInstance:代理类对象
        Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan);
        //当通过代理类对象调用方法时，会自动调用被代理类中同名的方法
        String fly = proxyInstance.fly();
        System.out.println(fly);
        proxyInstance.eat(" 火锅");
        System.out.println("*************************************");
    }

}

/**
 * 1.InvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，
 * 每一个proxy代理实例都有一个关联的调用处理程序；在代理实例调用方法时，方法调用被编码分派到调用处理程序的invoke方法。
 * 2.Proxy类就是用来创建一个代理对象的类，它提供了很多方法，但是我们最常用的是newProxyInstance方法。
 */
class MyInvocationHandler implements InvocationHandler {
    /**
     * 需要使用被代理类的对象进行赋值
     */
    private Object obj;

    /**
     * 该方法只是一个赋值
     *
     * @param obj
     */
    public void bind(Object obj) {
        this.obj = obj;
    }

    /**
     * 当我们通过代理类的对象，调用方法a时，就会自动调用如下方法：invoke()
     * 当被代理类要执行的方法a的功能就声明在invoke（）中
     *
     * @param proxy
     * @param method
     * @param args
     * @return
     * @throws Throwable
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //设置通用方法
        HumanUtil humanUtil = new HumanUtil();
        humanUtil.method1();
        //method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法，改了个名字而已
        //obj：被代理类的对象,从中调用底层方法的对象，必须是实例化对象
        //args： 用于方法的调用，是一个object的数组，参数有可能是多个
        Object invoke = method.invoke(obj, args);

        //设置通用方法二
        humanUtil.method2();
        //上述方法的返回值就是作为当前类中的invoke()的返回值
        return invoke;
    }
}

//被代理类
class SuperMan implements Human {
    @Override
    public String fly() {
        return "i believe i can fly";
    }

    @Override
    public void eat(String food) {
        System.out.println("i like eat" + food);
    }

}
class HumanUtil {
    public void method1() {
        System.out.println("================通用方法一==================");
    }

    public void method2() {
        System.out.println("================通用方法二==================");
    }
}
结果：
================通用方法一==================
================通用方法二==================
i believe i can fly
================通用方法一==================
i like eat 火锅
================通用方法二==================
*************************************
~~~

**注意**

- 因为这里的第一个fly方法是没有打印输出的，所以就只是执行了通用方法
- invoke这个类里面加了通用方法，相当于任何一个代理实例创建的时候，就会存在通用的方法
